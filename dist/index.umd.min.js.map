{"version":3,"file":"index.umd.min.js","sources":["../src/vird/vird-event.ts","../src/vird-node/vird-node-types.ts","../src/create-node/create-node-from-string.ts","../src/create-node/clone-node.ts","../src/create-node/create-node.ts","../src/create-node/create-node-from-node.ts","../src/vird/vird-properties.ts","../src/renderer/create-real-node.ts","../src/renderer/diff.ts","../src/renderer/diff-render.ts","../src/renderer/render.ts"],"sourcesContent":["import { VirdNode } from '../vird-node/vird-node'\n\nexport type VirdEventProperties = {\n  [K in keyof HTMLElementEventMap]: VirdEventValue<K> | string\n}\n\nexport type VirdEventValue<K extends string = string> =\n  | VirdEventListener<K>\n  | {\n      listener: VirdEventListener<K>\n      options: VirdEventListenerOptions\n    }\n\nexport type VirdEventListener<K extends string = string> = (\n  event: K extends keyof HTMLElementEventMap ? HTMLElementEventMap[K] : Event\n) => boolean | void\n\nexport type VirdEventListenerOptions =\n  | AddEventListenerOptions\n  | boolean\n  | undefined\n\nconst virdEventListenerMap: WeakMap<\n  VirdNode,\n  Map<string, Set<VirdEventListener<any>>>\n> = new WeakMap()\n\nconst listenerOptionsMap: WeakMap<\n  VirdEventListener<any>,\n  VirdEventListenerOptions\n> = new WeakMap()\n\nexport function addVirdEvent<K extends string>(\n  virdNode: VirdNode,\n  type: K,\n  listener: VirdEventListener<K>,\n  options?: VirdEventListenerOptions\n) {\n  let eventListenerMap = virdEventListenerMap.get(virdNode)\n  if (!eventListenerMap) {\n    eventListenerMap = new Map()\n    virdEventListenerMap.set(virdNode, eventListenerMap)\n  }\n\n  let events = eventListenerMap.get(type)\n  if (!events) {\n    events = new Set()\n    eventListenerMap.set(type, events)\n  }\n\n  events.add(listener)\n  listenerOptionsMap.set(listener, options)\n}\n\nexport function removeVirdEvent<K extends string>(\n  virdNode: VirdNode,\n  type: K,\n  listener: VirdEventListener<K>\n) {\n  const eventListenerMap = virdEventListenerMap.get(virdNode)\n  if (!eventListenerMap) return\n\n  const events = eventListenerMap.get(type)\n  if (!events) return\n\n  events.delete(listener)\n  listenerOptionsMap.delete(listener)\n}\n\nexport function getVirdEventMap(virdNode: VirdNode) {\n  const result: {\n    [key: string]: {\n      listener: VirdEventListener\n      options: VirdEventListenerOptions\n    }[]\n  } = {}\n\n  const eventListenerMap = virdEventListenerMap.get(virdNode)\n  if (eventListenerMap) {\n    for (const [key, listeners] of eventListenerMap) {\n      result[key] = []\n      for (const listener of listeners) {\n        const options = listenerOptionsMap.get(listener)\n        result[key].push({ listener, options })\n      }\n    }\n  }\n\n  return result\n}\n\nexport function cloneVirdEvent(\n  copyVirdNode: VirdNode,\n  masterVirdNode: VirdNode\n) {\n  const eventListenerMap = virdEventListenerMap.get(masterVirdNode)\n  if (!eventListenerMap) return\n\n  for (const [key, events] of eventListenerMap) {\n    for (const event of events) {\n      addVirdEvent(copyVirdNode, key, event)\n    }\n  }\n}\n","/** A type list with a special meaning in the VirdNode element. */\nexport interface VirdNodeTypes {\n  /** An string representing the VirdNodeText. */\n  readonly text: '#text'\n  /** An object representing the VirdNodeComment. */\n  readonly comment: '#comment'\n  /** An object representing the VirdNodeFragment. */\n  readonly fragment: '#document-fragment'\n}\n\nexport const virdNodeTypes: VirdNodeTypes = {\n  text: '#text',\n  comment: '#comment',\n  fragment: '#document-fragment'\n}\n","import {\n  VirdCommentNode,\n  VirdFragmentNode,\n  VirdNode,\n  VirdTextNode\n} from '../vird-node/vird-node'\nimport { virdNodeTypes } from '../vird-node/vird-node-types'\n\n/**\n * This createNodeFromString() function creates a VirdNode from a string.\n * @param type A string that represents the type of VirdNode to create.\n * @param properties An object that represents the properties of the VirdNode to create.\n * @param children An array that represents the child nodes of the VirdNode to create.\n */\nexport function createNodeFromString(\n  type: VirdTextNode['type'],\n  properties?: VirdTextNode['properties'],\n  children?: VirdTextNode['children']\n): VirdTextNode\nexport function createNodeFromString(\n  type: VirdCommentNode['type'],\n  properties?: VirdCommentNode['properties'],\n  children?: VirdCommentNode['children']\n): VirdCommentNode\nexport function createNodeFromString(\n  type: VirdFragmentNode['type'],\n  properties?: VirdFragmentNode['properties'],\n  children?: VirdFragmentNode['children']\n): VirdFragmentNode\nexport function createNodeFromString(\n  type: string,\n  properties?: VirdNode['properties'],\n  children?: VirdNode['children']\n): VirdNode\nexport function createNodeFromString(\n  type: string,\n  properties: VirdNode['properties'] = {},\n  children: VirdNode['children'] = []\n) {\n  type = type.toLocaleLowerCase()\n  properties = { ...properties }\n  children = [...children]\n\n  if (\n    !properties.textContent &&\n    (virdNodeTypes.text === type || virdNodeTypes.comment === type)\n  ) {\n    properties.textContent = ''\n  }\n\n  return { type, properties, children } as VirdNode\n}\n","import { VirdNode } from '../vird-node/vird-node'\nimport { cloneVirdEvent } from '../vird/vird-event'\nimport { createNodeFromString } from './create-node-from-string'\n\n/**\n * The options object specifies the replication characteristics.\n */\nexport interface CloneNodeOptions {\n  /**\n   * A boolean that recursively duplicates child nodes.\n   * If true, the node and its entire subtree are also copied.\n   * Initial value is false.\n   */\n  deep: boolean\n  /**\n   * A boolean that recursively duplicates the events.\n   * If true, apply the event registered in the node to the copy destination as well.\n   * Initial value is false.\n   */\n  event: boolean\n}\n\n/**\n * This cloneNode() function duplicates VirdNode.\n * @param virdNode VirdNode to duplicate.\n * @param options\n */\nexport function cloneNode<R extends VirdNode>(\n  virdNode: VirdNode,\n  options: Partial<CloneNodeOptions> | boolean = {}\n): R {\n  if (typeof options === 'boolean') {\n    options = { deep: options, event: options }\n  }\n\n  const { deep = false, event = false } = options\n\n  const type = virdNode.type\n  const properties = { ...virdNode.properties }\n  const children = deep\n    ? virdNode.children.map(child => cloneNode(child, options))\n    : []\n\n  const cloneVirdNode = createNodeFromString(type, properties, children)\n\n  if (event) {\n    cloneVirdEvent(cloneVirdNode, virdNode)\n  }\n\n  return cloneVirdNode as R\n}\n","import {\n  ToVirdNode,\n  VirdCommentNode,\n  VirdFragmentNode,\n  VirdNode,\n  VirdTextNode\n} from '../vird-node/vird-node'\nimport { VirdNodeTypes, virdNodeTypes } from '../vird-node/vird-node-types'\nimport { addVirdEvent } from '../vird/vird-event'\nimport { parseVirdProperties, VirdProperties } from '../vird/vird-properties'\nimport { cloneNode } from './clone-node'\nimport { createNodeFromNode } from './create-node-from-node'\nimport { createNodeFromString } from './create-node-from-string'\n\n/**\n * This createNode() function creates a VirdNode.\n * @param base The base item for the created VirdNode.\n * @param properties An objects representing the VirdNode properties to create.\n */\nexport function createNode<\n  T extends\n    | VirdNodeTypes['text']\n    | VirdNodeTypes['comment']\n    | Text\n    | Comment\n    | VirdTextNode\n    | VirdCommentNode\n>(base: T, properties: ToVirdNode<T>['properties']): ToVirdNode<T>\n\n/**\n * This createNode() function creates a VirdNode.\n * @param base The base item for the created VirdNode.\n * @param text The string assigned to the value of virdTextNode.properties.textContent.\n */\nexport function createNode<\n  T extends\n    | VirdNodeTypes['text']\n    | VirdNodeTypes['comment']\n    | Text\n    | Comment\n    | VirdTextNode\n    | VirdCommentNode\n>(base: T, text?: string): ToVirdNode<T>\n\n/**\n * This createNode() function creates a VirdNode.\n * @param base The base item for the created VirdNode.\n * @param trim\n * A Boolean value that specifies the removal of elements that do not significantly affect the rendering.\n * If true, remove comments and text elements containing only spaces and line breaks.\n */\nexport function createNode<\n  T extends VirdNodeTypes['fragment'] | DocumentFragment | VirdFragmentNode\n>(base: T, trim: boolean): ToVirdNode<T>\n\n/**\n * This createNode() function creates a VirdNode.\n * @param base The base item for the created VirdNode.\n * @param children An array or string that represents the children of the VirdNode.\n * @param trim\n * A Boolean value that specifies the removal of elements that do not significantly affect the rendering.\n * If true, remove comments and text elements containing only spaces and line breaks.\n */\nexport function createNode<\n  T extends VirdNodeTypes['fragment'] | DocumentFragment | VirdFragmentNode\n>(\n  base: T,\n  children: string | (string | VirdNode)[],\n  trim?: boolean\n): ToVirdNode<T>\n\n/**\n * This createNode() function creates a VirdNode.\n * @param base The base item for the created VirdNode.\n * @param childrenOrTrim Argument that can choose one of these.\n * - children : An array or string that represents the children of the VirdNode.\n * - trim : A Boolean value that specifies the removal of elements that do not significantly affect the rendering.\n * If true, remove comments and text elements containing only spaces and line breaks.\n */\nexport function createNode<\n  T extends VirdNodeTypes['fragment'] | DocumentFragment | VirdFragmentNode\n>(\n  base: T,\n  childrenOrTrim?: string | (string | VirdNode)[] | boolean\n): ToVirdNode<T>\n\n/**\n * This createNode() function creates a VirdNode.\n * @param base The base item for the created VirdNode.\n * @param properties An objects representing the VirdNode properties to create.\n * @param children An array or string that represents the children of the VirdNode.\n * @param trim\n * A Boolean value that specifies the removal of elements that do not significantly affect the rendering.\n * If true, remove comments and text elements containing only spaces and line breaks.\n */\nexport function createNode<T extends string | Node | VirdNode>(\n  base: T,\n  properties: Partial<VirdProperties>,\n  children: string | (string | VirdNode)[],\n  trim?: boolean\n): ToVirdNode<T>\n\n/**\n * This createNode() function creates a VirdNode.\n * @param base The base item for the created VirdNode.\n * @param properties An objects representing the VirdNode properties to create.\n * @param trim\n * A Boolean value that specifies the removal of elements that do not significantly affect the rendering.\n * If true, remove comments and text elements containing only spaces and line breaks.\n */\nexport function createNode<T extends string | Node | VirdNode>(\n  base: T,\n  properties: Partial<VirdProperties>,\n  trim: boolean\n): ToVirdNode<T>\n\n/**\n * This createNode() function creates a VirdNode.\n * @param base The base item for the created VirdNode.\n * @param children An array or string that represents the children of the VirdNode.\n * @param trim\n * A Boolean value that specifies the removal of elements that do not significantly affect the rendering.\n * If true, remove comments and text elements containing only spaces and line breaks.\n */\nexport function createNode<T extends string | Node | VirdNode>(\n  base: T,\n  children: string | (string | VirdNode)[],\n  trim?: boolean\n): ToVirdNode<T>\n\n/**\n * This createNode() function creates a VirdNode.\n * @param base The base item for the created VirdNode.\n * @param trim\n * A Boolean value that specifies the removal of elements that do not significantly affect the rendering.\n * If true, remove comments and text elements containing only spaces and line breaks.\n */\nexport function createNode<T extends string | Node | VirdNode>(\n  base: T,\n  trim: boolean\n): ToVirdNode<T>\n\n/**\n * This createNode() function creates a VirdNode.\n * @param base The base item for the created VirdNode.\n * @param properties An objects representing the VirdNode properties to create.\n * @param childrenOrTrim Argument that can choose one of these.\n * - children : An array or string that represents the children of the VirdNode.\n * - trim : A Boolean value that specifies the removal of elements that do not significantly affect the rendering.\n * If true, remove comments and text elements containing only spaces and line breaks.\n */\nexport function createNode<T extends string | Node | VirdNode>(\n  base: T,\n  properties: Partial<VirdProperties>,\n  childrenOrTrim?: string | (string | VirdNode)[] | boolean\n): ToVirdNode<T>\n\n/**\n * This createNode() function creates a VirdNode.\n * @param base The base item for the created VirdNode.\n * @param propertiesOrChildrenOrTrim Argument that can choose one of these.\n * - properties : An objects representing the VirdNode properties to create.\n * - children : An array or string that represents the children of the VirdNode.\n * - trim : A Boolean value that specifies the removal of elements that do not significantly affect the rendering.\n * If true, remove comments and text elements containing only spaces and line breaks.\n */\nexport function createNode<T extends string | Node | VirdNode>(\n  base: T,\n  propertiesOrChildrenOrTrim?:\n    | Partial<VirdProperties>\n    | string\n    | (string | VirdNode)[]\n    | boolean\n): ToVirdNode<T>\n\n/**\n * This createNode() function creates a VirdNode.\n * @param base The base item for the created VirdNode.\n * @param propertiesOrChildrenOrTrim Argument that can choose one of these.\n * - properties : An objects representing the VirdNode properties to create.\n * - children : An array or string that represents the children of the VirdNode.\n * - trim : A Boolean value that specifies the removal of elements that do not significantly affect the rendering.\n * If true, remove comments and text elements containing only spaces and line breaks.\n * @param childrenOrTrim Argument that can choose one of these.\n * - children : An array or string that represents the children of the VirdNode.\n * - trim : A Boolean value that specifies the removal of elements that do not significantly affect the rendering.\n * If true, remove comments and text elements containing only spaces and line breaks.\n * @param trim\n * A Boolean value that specifies the removal of elements that do not significantly affect the rendering.\n * If true, remove comments and text elements containing only spaces and line breaks.\n */\nexport function createNode<T extends string | Node | VirdNode>(\n  base: T,\n  propertiesOrChildrenOrTrim?:\n    | Partial<VirdProperties>\n    | string\n    | (string | VirdNode)[]\n    | boolean,\n  childrenOrTrim?: string | (string | VirdNode)[] | boolean,\n  trim?: boolean\n): ToVirdNode<T>\n\nexport function createNode<T extends string | Node | VirdNode>(\n  base: T,\n  propertiesOrChildrenOrTrim?:\n    | Partial<VirdProperties>\n    | string\n    | (string | VirdNode)[]\n    | boolean,\n  childrenOrTrim?: string | (string | VirdNode)[] | boolean,\n  trim?: boolean\n): ToVirdNode<T> {\n  // create virdNode\n  const virdNode =\n    typeof base === 'string'\n      ? createNodeFromString(base)\n      : base instanceof Node\n      ? createNodeFromNode(base, true)\n      : cloneNode(base as VirdNode, { deep: true })\n\n  // add properties\n  if (\n    typeof propertiesOrChildrenOrTrim === 'object' &&\n    !Array.isArray(propertiesOrChildrenOrTrim)\n  ) {\n    const { events, properties } = parseVirdProperties(\n      propertiesOrChildrenOrTrim\n    )\n\n    virdNode.properties = {\n      ...virdNode.properties,\n      ...properties\n    }\n\n    // add events\n    for (const key of Object.keys(events)) {\n      const value = events[key]\n      if (typeof value === 'function') {\n        addVirdEvent(virdNode, key, value)\n      } else {\n        addVirdEvent(virdNode, key, value.listener, value.options)\n      }\n    }\n  } else if (propertiesOrChildrenOrTrim !== undefined) {\n    childrenOrTrim = propertiesOrChildrenOrTrim\n  }\n\n  // add children\n  if (typeof childrenOrTrim === 'string') {\n    const lastTypes: string[] = [virdNodeTypes.text, virdNodeTypes.comment]\n    if (lastTypes.includes(virdNode.type)) {\n      virdNode.properties.textContent = childrenOrTrim\n    } else {\n      virdNode.children = [\n        createNodeFromString('#text', { textContent: childrenOrTrim })\n      ]\n    }\n  } else if (Array.isArray(childrenOrTrim)) {\n    virdNode.children = childrenOrTrim.map(stringOrVirdNode => {\n      return typeof stringOrVirdNode === 'string'\n        ? createNodeFromString('#text', { textContent: stringOrVirdNode })\n        : stringOrVirdNode\n    })\n  } else if (childrenOrTrim !== undefined) {\n    trim = childrenOrTrim\n  }\n\n  // trimming\n  if (trim) {\n    virdNode.children = virdNode.children.filter(child => {\n      if (child.type === virdNodeTypes.comment) return false\n      if (child.type === virdNodeTypes.text) {\n        if (child.properties.textContent === undefined) return false\n        if (!/^\\s*$/.test(child.properties.textContent)) return false\n      }\n\n      return true\n    })\n  }\n\n  return virdNode as ToVirdNode<T>\n}\n","import {\n  VirdCommentNode,\n  VirdFragmentNode,\n  VirdNode,\n  VirdTextNode\n} from '../vird-node/vird-node'\nimport { createNodeFromString } from './create-node-from-string'\n\n/**\n * This createNodeFromNode() function creates a VirdNode from a Node.\n * @param node\n * A Node is used when creating a VirdNode.\n * The type of VirdNode created is the nodeName property converted to lowercase.\n */\nexport function createNodeFromNode(node: Text): VirdTextNode\nexport function createNodeFromNode(node: Comment): VirdCommentNode\n\n/**\n * This createNodeFromNode() function creates a VirdNode from a Node.\n * @param node\n * A Node is used when creating a VirdNode.\n * The type of VirdNode created is the nodeName property converted to lowercase.\n * @param deep\n * A boolean that recursively duplicates child nodes.\n * If true, the node and its entire subtree are also transformed.\n * Initial value is false.\n */\nexport function createNodeFromNode(\n  node: DocumentFragment,\n  deep: boolean\n): VirdFragmentNode\nexport function createNodeFromNode(node: Node, deep?: boolean): VirdNode\nexport function createNodeFromNode(node: Node, deep = false): VirdNode {\n  const type = node.nodeName\n  const properties: VirdNode['properties'] = {}\n\n  if (node instanceof Element) {\n    for (const { name, value } of node.attributes) {\n      properties[name] = value\n    }\n  } else if (node instanceof Comment || node instanceof Text) {\n    properties.textContent = node.textContent || ''\n  }\n\n  const mapCallback = (child: Node) => createNodeFromNode(child, deep)\n  const children: VirdNode[] = deep ? [...node.childNodes].map(mapCallback) : []\n\n  return createNodeFromString(type, properties, children)\n}\n","import { VirdNode } from '../vird-node/vird-node'\nimport { VirdEventProperties, VirdEventValue } from './vird-event'\n\nexport type VirdProperties = {\n  [K in string]: VirdEventValue<K> | string\n} &\n  VirdEventProperties\n\nexport interface ParseVirdPropertiesResult {\n  events: { [key: string]: VirdEventValue }\n  properties: VirdNode['properties']\n}\n\nexport function parseVirdProperties(params: Partial<VirdProperties>) {\n  const result: ParseVirdPropertiesResult = {\n    events: {},\n    properties: {}\n  }\n\n  for (const key of Object.keys(params)) {\n    const value = params[key]\n\n    if (typeof value === 'string') {\n      result.properties[key] = value\n    } else if (value) {\n      result.events[key] = value\n    }\n  }\n\n  return result\n}\n","import { VirdNode } from '../vird-node/vird-node'\nimport { virdNodeTypes } from '../vird-node/vird-node-types'\n\nexport function createRealNode(virdNode: VirdNode) {\n  switch (virdNode.type) {\n    case virdNodeTypes.text:\n      return document.createTextNode(virdNode.properties.textContent || '')\n    case virdNodeTypes.comment:\n      return document.createComment(virdNode.properties.textContent || '')\n    default:\n      return document.createElement(virdNode.type)\n  }\n}\n","type DiffObject<T extends { [key: string]: any }> = {\n  [K in keyof T]?: [T[K] | undefined, T[K] | undefined]\n}\n\nexport function diff<T = { [key: string]: any }>(\n  checkObject?: T | undefined,\n  comparisonObjet?: T | undefined\n) {\n  const diffObject = {} as DiffObject<T>\n\n  if (checkObject !== comparisonObjet) {\n    if (checkObject) {\n      const checkObjectKey = Object.keys(checkObject) as (keyof T)[]\n      if (comparisonObjet) {\n        const comparisonObjetKey = Object.keys(comparisonObjet) as (keyof T)[]\n        const keys: Set<keyof T> = new Set([\n          ...checkObjectKey,\n          ...comparisonObjetKey\n        ])\n\n        for (const key of keys) {\n          const checkObjetValue = checkObject[key]\n          const comparisonObjetValue = comparisonObjet[key]\n          if (checkObjetValue === comparisonObjetValue) {\n            continue\n          }\n\n          diffObject[key] = [checkObjetValue, comparisonObjetValue]\n        }\n      } else {\n        for (const key of checkObjectKey) {\n          const value = checkObject[key]\n          diffObject[key] = [value, undefined]\n        }\n      }\n    } else {\n      if (comparisonObjet) {\n        const comparisonObjetKey = Object.keys(comparisonObjet) as (keyof T)[]\n        for (const key of comparisonObjetKey) {\n          const value = comparisonObjet[key]\n          diffObject[key] = [undefined, value]\n        }\n      }\n    }\n  }\n\n  return diffObject\n}\n","import { createNode } from '../create-node/create-node'\r\nimport { VirdNode } from '../vird-node/vird-node'\r\nimport { getVirdEventMap } from '../vird/vird-event'\r\nimport { createRealNode } from './create-real-node'\r\nimport { diff } from './diff'\r\n\r\nconst beforeVirdNodes: WeakMap<Node, VirdNode[]> = new WeakMap()\r\nconst nodeMap: WeakMap<VirdNode, Node> = new WeakMap()\r\nexport function diffRender(rootNode: Node, newVirdNodes: VirdNode[]) {\r\n  const oldVirdNodes =\r\n    beforeVirdNodes.get(rootNode) ||\r\n    [...rootNode.childNodes].map(child => createNode(child))\r\n\r\n  beforeVirdNodes.set(rootNode, newVirdNodes)\r\n\r\n  let index = 0\r\n  let newVirdNodeIndex = 0\r\n  let oldVirdNodeIndex = 0\r\n  const newVirdNodeLength = newVirdNodes.length\r\n  const oldVirdNodeLength = oldVirdNodes.length\r\n  const maxIndex = Math.max(newVirdNodeLength, oldVirdNodeLength)\r\n\r\n  while (index < maxIndex) {\r\n    const newVirdNode = newVirdNodes[newVirdNodeIndex] as VirdNode | undefined\r\n    const oldVirdNode = oldVirdNodes[oldVirdNodeIndex] as VirdNode | undefined\r\n    const oldNode = oldVirdNode && nodeMap.get(oldVirdNode)\r\n\r\n    if (newVirdNode) {\r\n      let nextNode = oldNode\r\n      if (!oldVirdNode || oldVirdNode.type !== newVirdNode.type) {\r\n        const realNode = createRealNode(newVirdNode)\r\n        nextNode = realNode\r\n\r\n        if (oldNode) {\r\n          beforeVirdNodes.delete(oldNode)\r\n\r\n          if (newVirdNodeLength > oldVirdNodeLength) {\r\n            rootNode.insertBefore(realNode, oldNode)\r\n            oldVirdNodeIndex--\r\n          } else if (newVirdNodeLength < oldVirdNodeLength) {\r\n            rootNode.removeChild(oldNode)\r\n            newVirdNodeIndex--\r\n          } else {\r\n            rootNode.replaceChild(realNode, oldNode)\r\n          }\r\n        } else {\r\n          rootNode.appendChild(realNode)\r\n        }\r\n      }\r\n\r\n      if (nextNode) {\r\n        nodeMap.set(newVirdNode, nextNode)\r\n\r\n        const diffProperties = diff(\r\n          newVirdNode.properties,\r\n          oldVirdNode && oldVirdNode.properties\r\n        )\r\n\r\n        if (nextNode instanceof Element) {\r\n          for (const name of Object.keys(diffProperties)) {\r\n            const newValue = diffProperties[name]\r\n            const value = newValue && newValue[0]\r\n\r\n            if (value) {\r\n              nextNode.setAttribute(name, value)\r\n            } else {\r\n              nextNode.removeAttribute(name)\r\n            }\r\n          }\r\n\r\n          if (oldVirdNode) {\r\n            const oldEventMap = getVirdEventMap(oldVirdNode)\r\n            for (const name of Object.keys(oldEventMap)) {\r\n              const eventMap = oldEventMap[name]\r\n              for (const { listener } of eventMap) {\r\n                nextNode.removeEventListener(name, listener)\r\n              }\r\n            }\r\n          }\r\n\r\n          const oldEventMap = getVirdEventMap(newVirdNode)\r\n          for (const name of Object.keys(oldEventMap)) {\r\n            const eventMap = oldEventMap[name]\r\n            for (const { listener, options } of eventMap) {\r\n              nextNode.addEventListener(name, listener, options)\r\n            }\r\n          }\r\n        } else {\r\n          if (diffProperties.textContent) {\r\n            nextNode.textContent = diffProperties.textContent[0] || ''\r\n          }\r\n        }\r\n\r\n        diffRender(nextNode, newVirdNode.children)\r\n      }\r\n    } else if (oldNode) {\r\n      const parent = oldNode.parentElement\r\n      if (parent) {\r\n        parent.removeChild(oldNode)\r\n      }\r\n    }\r\n\r\n    index++\r\n    newVirdNodeIndex++\r\n    oldVirdNodeIndex++\r\n  }\r\n}\r\n","import { cloneNode } from '../create-node/clone-node'\nimport { VirdNode } from '../vird-node/vird-node'\nimport { virdNodeTypes } from '../vird-node/vird-node-types'\nimport { diffRender } from './diff-render'\n\nfunction filterIgnoreVirdNode(virdNodes: VirdNode[]) {\n  const result: VirdNode[] = []\n\n  for (const virdNode of virdNodes) {\n    if (virdNode.type === virdNodeTypes.fragment) {\n      const children = filterIgnoreVirdNode(virdNode.children)\n      result.push(...children)\n    } else {\n      result.push(virdNode)\n    }\n  }\n\n  return result\n}\n\nexport function render(rootNode: Node, ...virdNodes: VirdNode[]) {\n  const newVirdNodeLength = virdNodes.length\n  if (newVirdNodeLength < 1) return\n\n  // Create a VirdNode for rendering.\n  const clone = (virdNode: VirdNode) => cloneNode(virdNode, true)\n  const newVirdNodes = filterIgnoreVirdNode(virdNodes).map(clone)\n\n  // rendering.\n  diffRender(rootNode, newVirdNodes)\n}\n"],"names":["virdEventListenerMap","WeakMap","listenerOptionsMap","addVirdEvent","virdNode","type","listener","options","eventListenerMap","get","Map","set","events","Set","add","getVirdEventMap","result","key","listeners","push","virdNodeTypes","createNodeFromString","properties","children","toLocaleLowerCase","textContent","cloneNode","deep","event","cloneVirdNode","map","child","copyVirdNode","masterVirdNode","cloneVirdEvent","createNode","base","propertiesOrChildrenOrTrim","childrenOrTrim","trim","Node","createNodeFromNode","node","nodeName","Element","name","value","attributes","Comment","Text","childNodes","Array","isArray","undefined","params","Object","keys","parseVirdProperties","includes","stringOrVirdNode","filter","test","createRealNode","document","createTextNode","createComment","createElement","diff","checkObject","comparisonObjet","diffObject","checkObjectKey","comparisonObjetKey","checkObjetValue","comparisonObjetValue","beforeVirdNodes","nodeMap","rootNode","virdNodes","length","diffRender","newVirdNodes","oldVirdNodes","index","newVirdNodeIndex","oldVirdNodeIndex","newVirdNodeLength","oldVirdNodeLength","maxIndex","Math","max","newVirdNode","oldVirdNode","oldNode","nextNode","realNode","delete","insertBefore","removeChild","replaceChild","appendChild","diffProperties","newValue","setAttribute","removeAttribute","oldEventMap","eventMap","removeEventListener","addEventListener","parent","parentElement","filterIgnoreVirdNode"],"mappings":"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"}