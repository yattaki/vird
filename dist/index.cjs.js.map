{"version":3,"file":"index.cjs.js","sources":["../src/vird/vird-event.ts","../src/vird-node/vird-node-types.ts","../src/create-node/create-node-from-string.ts","../src/create-node/clone-node.ts","../src/vird/vird-properties.ts","../src/create-node/create-node-from-node.ts","../src/create-node/create-node.ts","../src/renderer/reserve.ts","../src/renderer/update-attributes.ts","../src/renderer/vird-dom.ts","../src/renderer/create-real-node.ts","../src/renderer/diff.ts","../src/renderer/diff-render.ts","../src/renderer/render.ts"],"sourcesContent":["import { VirdNode } from '../vird-node/vird-node'\n\nexport type VirdEventProperties = {\n  [K in keyof HTMLElementEventMap]: VirdEventValue<K> | string\n}\n\nexport type VirdEventValue<K extends string = string> =\n  | VirdEventListener<K>\n  | {\n      listener: VirdEventListener<K>\n      options: VirdEventListenerOptions\n    }\n\nexport type VirdEventListener<K extends string = string> = (\n  event: K extends keyof HTMLElementEventMap ? HTMLElementEventMap[K] : Event\n) => boolean | void\n\nexport type VirdEventListenerOptions =\n  | AddEventListenerOptions\n  | boolean\n  | undefined\n\nconst virdEventListenerMap: WeakMap<\n  VirdNode,\n  Map<string, Set<VirdEventListener<any>>>\n> = new WeakMap()\n\nconst listenerOptionsMap: WeakMap<\n  VirdEventListener<any>,\n  VirdEventListenerOptions\n> = new WeakMap()\n\nexport function addVirdEvent<K extends string>(\n  virdNode: VirdNode,\n  type: K,\n  listener: VirdEventListener<K>,\n  options?: VirdEventListenerOptions\n) {\n  let eventListenerMap = virdEventListenerMap.get(virdNode)\n  if (!eventListenerMap) {\n    eventListenerMap = new Map()\n    virdEventListenerMap.set(virdNode, eventListenerMap)\n  }\n\n  let events = eventListenerMap.get(type)\n  if (!events) {\n    events = new Set()\n    eventListenerMap.set(type, events)\n  }\n\n  events.add(listener)\n  listenerOptionsMap.set(listener, options)\n}\n\nexport function removeVirdEvent<K extends string>(\n  virdNode: VirdNode,\n  type: K,\n  listener: VirdEventListener<K>\n) {\n  const eventListenerMap = virdEventListenerMap.get(virdNode)\n  if (!eventListenerMap) return\n\n  const events = eventListenerMap.get(type)\n  if (!events) return\n\n  events.delete(listener)\n  listenerOptionsMap.delete(listener)\n}\n\nexport function clearVirdEvent(virdEvent: VirdNode) {\n  virdEventListenerMap.delete(virdEvent)\n}\n\nexport function cloneVirdEvent(\n  copyVirdNode: VirdNode,\n  masterVirdNode: VirdNode\n) {\n  const eventListenerMap = virdEventListenerMap.get(masterVirdNode)\n  if (!eventListenerMap) return\n\n  for (const [key, events] of eventListenerMap) {\n    for (const event of events) {\n      addVirdEvent(copyVirdNode, key, event)\n    }\n  }\n}\n\nexport function onEvent(node: Node, virdNode: VirdNode) {\n  const eventListenerMap = virdEventListenerMap.get(virdNode)\n  if (eventListenerMap) {\n    for (const [name, eventMap] of eventListenerMap) {\n      for (const listener of eventMap) {\n        node.addEventListener(name, listener, listenerOptionsMap.get(listener))\n      }\n    }\n  }\n}\n\nexport function offEvent(node: Node, virdNode: VirdNode) {\n  const eventListenerMap = virdEventListenerMap.get(virdNode)\n  if (eventListenerMap) {\n    for (const [name, eventMap] of eventListenerMap) {\n      for (const listener of eventMap) {\n        node.removeEventListener(name, listener)\n      }\n    }\n  }\n}\n","/** A type list with a special meaning in the VirdNode element. */\nexport interface VirdNodeTypes {\n  /** An string representing the VirdNodeText. */\n  readonly text: '#text'\n  /** An object representing the VirdNodeComment. */\n  readonly comment: '#comment'\n  /** An object representing the VirdNodeFragment. */\n  readonly fragment: '#document-fragment'\n}\n\nexport const virdNodeTypes: VirdNodeTypes = {\n  text: '#text',\n  comment: '#comment',\n  fragment: '#document-fragment'\n}\n","import {\n  VirdCommentNode,\n  VirdFragmentNode,\n  VirdNode,\n  VirdTextNode\n} from '../vird-node/vird-node'\nimport { virdNodeTypes } from '../vird-node/vird-node-types'\n\n/**\n * This createNodeFromString() function creates a VirdNode from a string.\n * @param type A string that represents the type of VirdNode to create.\n * @param properties An object that represents the properties of the VirdNode to create.\n * @param children An array that represents the child nodes of the VirdNode to create.\n */\nexport function createNodeFromString(\n  type: VirdTextNode['type'],\n  properties?: VirdTextNode['properties'],\n  children?: VirdTextNode['children']\n): VirdTextNode\nexport function createNodeFromString(\n  type: VirdCommentNode['type'],\n  properties?: VirdCommentNode['properties'],\n  children?: VirdCommentNode['children']\n): VirdCommentNode\nexport function createNodeFromString(\n  type: VirdFragmentNode['type'],\n  properties?: VirdFragmentNode['properties'],\n  children?: VirdFragmentNode['children']\n): VirdFragmentNode\nexport function createNodeFromString(\n  type: string,\n  properties?: VirdNode['properties'],\n  children?: VirdNode['children']\n): VirdNode\nexport function createNodeFromString(\n  type: string,\n  properties: VirdNode['properties'] = {},\n  children: VirdNode['children'] = []\n) {\n  type = type.toLocaleLowerCase()\n  properties = { ...properties }\n  children = [...children]\n\n  if (\n    !properties.textContent &&\n    (virdNodeTypes.text === type || virdNodeTypes.comment === type)\n  ) {\n    properties.textContent = ''\n  }\n\n  return { type, properties, children } as VirdNode\n}\n","import { VirdNode } from '../vird-node/vird-node'\nimport { cloneVirdEvent } from '../vird/vird-event'\nimport { createNodeFromString } from './create-node-from-string'\n\n/**\n * The options object specifies the replication characteristics.\n */\nexport interface CloneNodeOptions {\n  /**\n   * A boolean that recursively duplicates child nodes.\n   * If true, the node and its entire subtree are also copied.\n   * Initial value is false.\n   */\n  deep: boolean\n  /**\n   * A boolean that recursively duplicates the events.\n   * If true, apply the event registered in the node to the copy destination as well.\n   * Initial value is false.\n   */\n  event: boolean\n}\n\n/**\n * This cloneNode() function duplicates VirdNode.\n * @param virdNode VirdNode to duplicate.\n * @param options\n */\nexport function cloneNode<R extends VirdNode>(\n  virdNode: VirdNode,\n  options: Partial<CloneNodeOptions> | boolean = {}\n): R {\n  if (typeof options === 'boolean') {\n    options = { deep: options, event: options }\n  }\n\n  const { deep = false, event = false } = options\n\n  const type = virdNode.type\n  const properties = { ...virdNode.properties }\n  const children = deep\n    ? virdNode.children.map(child => cloneNode(child, options))\n    : []\n\n  const cloneVirdNode = createNodeFromString(type, properties, children)\n\n  if (event) {\n    cloneVirdEvent(cloneVirdNode, virdNode)\n  }\n\n  return cloneVirdNode as R\n}\n","import { VirdNode } from '../vird-node/vird-node'\nimport { VirdEventProperties, VirdEventValue } from './vird-event'\n\nexport type VirdProperties = {\n  [K in string]: VirdEventValue<K> | string\n} &\n  VirdEventProperties\n\nexport interface ParseVirdPropertiesResult {\n  events: { [key: string]: VirdEventValue }\n  properties: VirdNode['properties']\n}\n\nexport function parseVirdProperties(params: Partial<VirdProperties>) {\n  const result: ParseVirdPropertiesResult = {\n    events: {},\n    properties: {}\n  }\n\n  for (const key of Object.keys(params)) {\n    const value = params[key]\n\n    if (typeof value === 'string') {\n      result.properties[key] = value\n    } else if (value) {\n      result.events[key] = value\n    }\n  }\n\n  return result\n}\n","import {\n  VirdCommentNode,\n  VirdFragmentNode,\n  VirdNode,\n  VirdTextNode\n} from '../vird-node/vird-node'\nimport { createNodeFromString } from './create-node-from-string'\n\n/**\n * This createNodeFromNode() function creates a VirdNode from a Node.\n * @param node\n * A Node is used when creating a VirdNode.\n * The type of VirdNode created is the nodeName property converted to lowercase.\n */\nexport function createNodeFromNode(node: Text): VirdTextNode\nexport function createNodeFromNode(node: Comment): VirdCommentNode\n\n/**\n * This createNodeFromNode() function creates a VirdNode from a Node.\n * @param node\n * A Node is used when creating a VirdNode.\n * The type of VirdNode created is the nodeName property converted to lowercase.\n * @param deep\n * A boolean that recursively duplicates child nodes.\n * If true, the node and its entire subtree are also transformed.\n * Initial value is false.\n */\nexport function createNodeFromNode(\n  node: DocumentFragment,\n  deep: boolean\n): VirdFragmentNode\nexport function createNodeFromNode(node: Node, deep?: boolean): VirdNode\nexport function createNodeFromNode(node: Node, deep = false): VirdNode {\n  const type = node.nodeName\n  const properties: VirdNode['properties'] = {}\n\n  if (node instanceof Element) {\n    for (const { name, value } of node.attributes) {\n      properties[name] = value\n    }\n\n    if ('value' in node) {\n      properties.value = (node as HTMLInputElement).value\n    }\n  } else if (node instanceof Comment || node instanceof Text) {\n    properties.textContent = node.textContent || ''\n  }\n\n  const mapCallback = (child: Node) => createNodeFromNode(child, deep)\n  const children: VirdNode[] = deep ? [...node.childNodes].map(mapCallback) : []\n\n  return createNodeFromString(type, properties, children)\n}\n","import {\n  ToVirdNode,\n  VirdCommentNode,\n  VirdFragmentNode,\n  VirdNode,\n  VirdTextNode\n} from '../vird-node/vird-node'\nimport { VirdNodeTypes, virdNodeTypes } from '../vird-node/vird-node-types'\nimport { addVirdEvent } from '../vird/vird-event'\nimport { parseVirdProperties, VirdProperties } from '../vird/vird-properties'\nimport { cloneNode } from './clone-node'\nimport { createNodeFromNode } from './create-node-from-node'\nimport { createNodeFromString } from './create-node-from-string'\n\n/**\n * This createNode() function creates a VirdNode.\n * @param base The base item for the created VirdNode.\n * @param properties An objects representing the VirdNode properties to create.\n */\nexport function createNode<\n  T extends\n    | VirdNodeTypes['text']\n    | VirdNodeTypes['comment']\n    | Text\n    | Comment\n    | VirdTextNode\n    | VirdCommentNode\n>(base: T, properties: ToVirdNode<T>['properties']): ToVirdNode<T>\n\n/**\n * This createNode() function creates a VirdNode.\n * @param base The base item for the created VirdNode.\n * @param text The string assigned to the value of virdTextNode.properties.textContent.\n */\nexport function createNode<\n  T extends\n    | VirdNodeTypes['text']\n    | VirdNodeTypes['comment']\n    | Text\n    | Comment\n    | VirdTextNode\n    | VirdCommentNode\n>(base: T, text?: string): ToVirdNode<T>\n\n/**\n * This createNode() function creates a VirdNode.\n * @param base The base item for the created VirdNode.\n * @param trim\n * A Boolean value that specifies the removal of elements that do not significantly affect the rendering.\n * If true, remove comments and text elements containing only spaces and line breaks.\n */\nexport function createNode<\n  T extends VirdNodeTypes['fragment'] | DocumentFragment | VirdFragmentNode\n>(base: T, trim: boolean): ToVirdNode<T>\n\n/**\n * This createNode() function creates a VirdNode.\n * @param base The base item for the created VirdNode.\n * @param children An array or string that represents the children of the VirdNode.\n * @param trim\n * A Boolean value that specifies the removal of elements that do not significantly affect the rendering.\n * If true, remove comments and text elements containing only spaces and line breaks.\n */\nexport function createNode<\n  T extends VirdNodeTypes['fragment'] | DocumentFragment | VirdFragmentNode\n>(\n  base: T,\n  children: string | (string | VirdNode)[],\n  trim?: boolean\n): ToVirdNode<T>\n\n/**\n * This createNode() function creates a VirdNode.\n * @param base The base item for the created VirdNode.\n * @param childrenOrTrim Argument that can choose one of these.\n * - children : An array or string that represents the children of the VirdNode.\n * - trim : A Boolean value that specifies the removal of elements that do not significantly affect the rendering.\n * If true, remove comments and text elements containing only spaces and line breaks.\n */\nexport function createNode<\n  T extends VirdNodeTypes['fragment'] | DocumentFragment | VirdFragmentNode\n>(\n  base: T,\n  childrenOrTrim?: string | (string | VirdNode)[] | boolean\n): ToVirdNode<T>\n\n/**\n * This createNode() function creates a VirdNode.\n * @param base The base item for the created VirdNode.\n * @param properties An objects representing the VirdNode properties to create.\n * @param children An array or string that represents the children of the VirdNode.\n * @param trim\n * A Boolean value that specifies the removal of elements that do not significantly affect the rendering.\n * If true, remove comments and text elements containing only spaces and line breaks.\n */\nexport function createNode<T extends string | Node | VirdNode>(\n  base: T,\n  properties: Partial<VirdProperties>,\n  children: string | (string | VirdNode)[],\n  trim?: boolean\n): ToVirdNode<T>\n\n/**\n * This createNode() function creates a VirdNode.\n * @param base The base item for the created VirdNode.\n * @param properties An objects representing the VirdNode properties to create.\n * @param trim\n * A Boolean value that specifies the removal of elements that do not significantly affect the rendering.\n * If true, remove comments and text elements containing only spaces and line breaks.\n */\nexport function createNode<T extends string | Node | VirdNode>(\n  base: T,\n  properties: Partial<VirdProperties>,\n  trim: boolean\n): ToVirdNode<T>\n\n/**\n * This createNode() function creates a VirdNode.\n * @param base The base item for the created VirdNode.\n * @param children An array or string that represents the children of the VirdNode.\n * @param trim\n * A Boolean value that specifies the removal of elements that do not significantly affect the rendering.\n * If true, remove comments and text elements containing only spaces and line breaks.\n */\nexport function createNode<T extends string | Node | VirdNode>(\n  base: T,\n  children: string | (string | VirdNode)[],\n  trim?: boolean\n): ToVirdNode<T>\n\n/**\n * This createNode() function creates a VirdNode.\n * @param base The base item for the created VirdNode.\n * @param trim\n * A Boolean value that specifies the removal of elements that do not significantly affect the rendering.\n * If true, remove comments and text elements containing only spaces and line breaks.\n */\nexport function createNode<T extends string | Node | VirdNode>(\n  base: T,\n  trim: boolean\n): ToVirdNode<T>\n\n/**\n * This createNode() function creates a VirdNode.\n * @param base The base item for the created VirdNode.\n * @param properties An objects representing the VirdNode properties to create.\n * @param childrenOrTrim Argument that can choose one of these.\n * - children : An array or string that represents the children of the VirdNode.\n * - trim : A Boolean value that specifies the removal of elements that do not significantly affect the rendering.\n * If true, remove comments and text elements containing only spaces and line breaks.\n */\nexport function createNode<T extends string | Node | VirdNode>(\n  base: T,\n  properties: Partial<VirdProperties>,\n  childrenOrTrim?: string | (string | VirdNode)[] | boolean\n): ToVirdNode<T>\n\n/**\n * This createNode() function creates a VirdNode.\n * @param base The base item for the created VirdNode.\n * @param propertiesOrChildrenOrTrim Argument that can choose one of these.\n * - properties : An objects representing the VirdNode properties to create.\n * - children : An array or string that represents the children of the VirdNode.\n * - trim : A Boolean value that specifies the removal of elements that do not significantly affect the rendering.\n * If true, remove comments and text elements containing only spaces and line breaks.\n */\nexport function createNode<T extends string | Node | VirdNode>(\n  base: T,\n  propertiesOrChildrenOrTrim?:\n    | Partial<VirdProperties>\n    | string\n    | (string | VirdNode)[]\n    | boolean\n): ToVirdNode<T>\n\n/**\n * This createNode() function creates a VirdNode.\n * @param base The base item for the created VirdNode.\n * @param propertiesOrChildrenOrTrim Argument that can choose one of these.\n * - properties : An objects representing the VirdNode properties to create.\n * - children : An array or string that represents the children of the VirdNode.\n * - trim : A Boolean value that specifies the removal of elements that do not significantly affect the rendering.\n * If true, remove comments and text elements containing only spaces and line breaks.\n * @param childrenOrTrim Argument that can choose one of these.\n * - children : An array or string that represents the children of the VirdNode.\n * - trim : A Boolean value that specifies the removal of elements that do not significantly affect the rendering.\n * If true, remove comments and text elements containing only spaces and line breaks.\n * @param trim\n * A Boolean value that specifies the removal of elements that do not significantly affect the rendering.\n * If true, remove comments and text elements containing only spaces and line breaks.\n */\nexport function createNode<T extends string | Node | VirdNode>(\n  base: T,\n  propertiesOrChildrenOrTrim?:\n    | Partial<VirdProperties>\n    | string\n    | (string | VirdNode)[]\n    | boolean,\n  childrenOrTrim?: string | (string | VirdNode)[] | boolean,\n  trim?: boolean\n): ToVirdNode<T>\n\nexport function createNode<T extends string | Node | VirdNode>(\n  base: T,\n  propertiesOrChildrenOrTrim?:\n    | Partial<VirdProperties>\n    | string\n    | (string | VirdNode)[]\n    | boolean,\n  childrenOrTrim?: string | (string | VirdNode)[] | boolean,\n  trim?: boolean\n): ToVirdNode<T> {\n  // create virdNode\n  const virdNode =\n    typeof base === 'string'\n      ? createNodeFromString(base)\n      : base instanceof Node\n      ? createNodeFromNode(base, true)\n      : cloneNode(base as VirdNode, { deep: true })\n\n  // add properties\n  if (\n    typeof propertiesOrChildrenOrTrim === 'object' &&\n    !Array.isArray(propertiesOrChildrenOrTrim)\n  ) {\n    const { events, properties } = parseVirdProperties(\n      propertiesOrChildrenOrTrim\n    )\n\n    virdNode.properties = {\n      ...virdNode.properties,\n      ...properties\n    }\n\n    // add events\n    for (const key of Object.keys(events)) {\n      const value = events[key]\n      if (typeof value === 'function') {\n        addVirdEvent(virdNode, key, value)\n      } else {\n        addVirdEvent(virdNode, key, value.listener, value.options)\n      }\n    }\n  } else if (propertiesOrChildrenOrTrim !== undefined) {\n    childrenOrTrim = propertiesOrChildrenOrTrim\n  }\n\n  // add children\n  if (typeof childrenOrTrim === 'string') {\n    const lastTypes: string[] = [virdNodeTypes.text, virdNodeTypes.comment]\n    if (lastTypes.includes(virdNode.type)) {\n      virdNode.properties.textContent = childrenOrTrim\n    } else {\n      virdNode.children = [\n        createNodeFromString('#text', { textContent: childrenOrTrim })\n      ]\n    }\n  } else if (Array.isArray(childrenOrTrim)) {\n    virdNode.children = childrenOrTrim.map(stringOrVirdNode => {\n      return typeof stringOrVirdNode === 'string'\n        ? createNodeFromString('#text', { textContent: stringOrVirdNode })\n        : stringOrVirdNode\n    })\n  } else if (childrenOrTrim !== undefined) {\n    trim = childrenOrTrim\n  }\n\n  // trimming\n  if (trim) {\n    virdNode.children = virdNode.children.filter(child => {\n      if (child.type === virdNodeTypes.comment) return false\n      if (child.type === virdNodeTypes.text) {\n        if (child.properties.textContent === undefined) return false\n        if (!/^\\s*$/.test(child.properties.textContent)) return false\n      }\n\n      return true\n    })\n  }\n\n  return virdNode as ToVirdNode<T>\n}\n","export const reserves: number[] = []\n","export function updateAttribute(\n  element: Element,\n  name: string,\n  value?: string | number | boolean | string[] | null\n) {\n  if (value != null) {\n    const attrValue = Array.isArray(value) ? value.join(' ') : String(value)\n\n    switch (name) {\n      case 'value':\n        ;(element as HTMLInputElement).value = attrValue\n        break\n\n      default:\n        element.setAttribute(name, attrValue)\n        break\n    }\n  } else {\n    element.removeAttribute(name)\n  }\n}\n","import { VirdNode } from '../vird-node/vird-node'\n\nexport const virdDom: WeakMap<Node, VirdNode[]> = new WeakMap()\nexport const nodeMap: WeakMap<VirdNode, Node> = new WeakMap()\n","import { cloneNode } from '../create-node/clone-node'\nimport { VirdNode } from '../vird-node/vird-node'\nimport { virdNodeTypes } from '../vird-node/vird-node-types'\nimport { onEvent } from '../vird/vird-event'\nimport { reserves } from './reserve'\nimport { updateAttribute } from './update-attributes'\nimport { nodeMap, virdDom } from './vird-dom'\n\nfunction createElement(virdNode: VirdNode) {\n  const element = document.createElement(virdNode.type)\n\n  for (const name of Object.keys(virdNode.properties)) {\n    updateAttribute(element, name, virdNode.properties[name])\n  }\n\n  onEvent(element, virdNode)\n\n  const clone = (virdNode: VirdNode) => cloneNode(virdNode, true)\n  const cloneVirdNodes = virdNode.children.map(clone)\n\n  const fragment = document.createDocumentFragment()\n  for (const child of cloneVirdNodes) {\n    const childNode = createRealNode(child)\n    fragment.appendChild(childNode)\n  }\n\n  const renderingReserve = requestAnimationFrame(() => {\n    element.appendChild(fragment)\n    virdDom.set(element, cloneVirdNodes)\n  })\n  reserves.push(renderingReserve)\n\n  return element\n}\n\n/**\n * The createRealNode() function creates a node from VirdNode.\n * @param virdNode The VirdNode object from which it is created.\n */\nexport function createRealNode(virdNode: VirdNode) {\n  let node: Node\n  switch (virdNode.type) {\n    case virdNodeTypes.text:\n      node = document.createTextNode(virdNode.properties.textContent || '')\n      break\n    case virdNodeTypes.comment:\n      node = document.createComment(virdNode.properties.textContent || '')\n      break\n    default:\n      node = createElement(virdNode)\n  }\n\n  nodeMap.set(virdNode, node)\n\n  return node\n}\n","type DiffObject<T extends { [key: string]: any }> = {\n  [K in keyof T]?: [T[K] | undefined, T[K] | undefined]\n}\n\n/**\n * The diff () function gets the diff of an object.\n * @param checkObject An object to compare the differences.\n * @param comparisonObjet An object to compare.\n */\nexport function diff<T = { [key: string]: any }>(\n  checkObject?: T | undefined,\n  comparisonObjet?: T | undefined\n) {\n  const diffObject = {} as DiffObject<T>\n\n  if (checkObject !== comparisonObjet) {\n    if (checkObject) {\n      const checkObjectKey = Object.keys(checkObject) as (keyof T)[]\n      if (comparisonObjet) {\n        const comparisonObjetKey = Object.keys(comparisonObjet) as (keyof T)[]\n        const keys: Set<keyof T> = new Set([\n          ...checkObjectKey,\n          ...comparisonObjetKey\n        ])\n\n        for (const key of keys) {\n          const checkObjetValue = checkObject[key]\n          const comparisonObjetValue = comparisonObjet[key]\n          if (checkObjetValue === comparisonObjetValue) {\n            continue\n          }\n\n          diffObject[key] = [checkObjetValue, comparisonObjetValue]\n        }\n      } else {\n        for (const key of checkObjectKey) {\n          const value = checkObject[key]\n          diffObject[key] = [value, undefined]\n        }\n      }\n    } else {\n      if (comparisonObjet) {\n        const comparisonObjetKey = Object.keys(comparisonObjet) as (keyof T)[]\n        for (const key of comparisonObjetKey) {\n          const value = comparisonObjet[key]\n          diffObject[key] = [undefined, value]\n        }\n      }\n    }\n  }\n\n  return diffObject\n}\n","import { createNode } from '../create-node/create-node'\nimport { VirdNode } from '../vird-node/vird-node'\nimport { clearVirdEvent, offEvent, onEvent } from '../vird/vird-event'\nimport { createRealNode } from './create-real-node'\nimport { diff } from './diff'\nimport { updateAttribute } from './update-attributes'\nimport { nodeMap, virdDom } from './vird-dom'\n\nfunction removeVirdDom(node: Node) {\n  virdDom.delete(node)\n  for (const childNode of node.childNodes) {\n    removeVirdDom(childNode)\n  }\n}\n\nexport function diffRender(rootNode: Node, newVirdNodes: VirdNode[]) {\n  const oldVirdNodes =\n    virdDom.get(rootNode) ||\n    [...rootNode.childNodes].map(child => createNode(child))\n\n  let index = 0\n  let newVirdNodeIndex = 0\n  let oldVirdNodeIndex = 0\n  const newVirdNodeLength = newVirdNodes.length\n  const oldVirdNodeLength = oldVirdNodes.length\n  const maxIndex = Math.max(newVirdNodeLength, oldVirdNodeLength)\n\n  while (index < maxIndex) {\n    const newVirdNode = newVirdNodes[newVirdNodeIndex] as VirdNode | undefined\n    const oldVirdNode = oldVirdNodes[oldVirdNodeIndex] as VirdNode | undefined\n    const oldNode = oldVirdNode && nodeMap.get(oldVirdNode)\n\n    if (newVirdNode) {\n      if (!oldVirdNode || oldVirdNode.type !== newVirdNode.type) {\n        const realNode = createRealNode(newVirdNode)\n\n        if (oldNode) {\n          removeVirdDom(oldNode)\n          const parent = oldNode.parentElement\n          if (parent === rootNode) {\n            if (newVirdNodeLength > oldVirdNodeLength) {\n              parent.insertBefore(realNode, oldNode)\n              oldVirdNodeIndex--\n            } else if (newVirdNodeLength < oldVirdNodeLength) {\n              parent.removeChild(oldNode)\n              newVirdNodeIndex--\n            } else {\n              parent.replaceChild(realNode, oldNode)\n            }\n          }\n        } else {\n          rootNode.appendChild(realNode)\n        }\n      } else if (oldNode) {\n        nodeMap.delete(oldVirdNode)\n        nodeMap.set(newVirdNode, oldNode)\n\n        const diffProperties = diff(\n          newVirdNode.properties,\n          oldVirdNode.properties\n        )\n\n        if (oldNode instanceof Element) {\n          for (const name of Object.keys(diffProperties)) {\n            const newValue = diffProperties[name]\n            const value = newValue && newValue[0]\n\n            updateAttribute(oldNode, name, value)\n          }\n\n          if (oldVirdNode) {\n            offEvent(oldNode, oldVirdNode)\n            clearVirdEvent(oldVirdNode)\n          }\n\n          onEvent(oldNode, newVirdNode)\n        } else {\n          if (diffProperties.textContent) {\n            oldNode.textContent = diffProperties.textContent[0] || ''\n          }\n        }\n\n        diffRender(oldNode, newVirdNode.children)\n      }\n    } else if (oldNode) {\n      const parent = oldNode.parentElement\n      if (parent) {\n        parent.removeChild(oldNode)\n      }\n    }\n\n    index++\n    newVirdNodeIndex++\n    oldVirdNodeIndex++\n  }\n\n  virdDom.set(rootNode, newVirdNodes)\n}\n","import { cloneNode } from '../create-node/clone-node'\nimport { VirdNode } from '../vird-node/vird-node'\nimport { virdNodeTypes } from '../vird-node/vird-node-types'\nimport { diffRender } from './diff-render'\nimport { reserves } from './reserve'\n\nfunction filterIgnoreVirdNode(virdNodes: VirdNode[]) {\n  const result: VirdNode[] = []\n\n  for (const virdNode of virdNodes) {\n    if (virdNode.type === virdNodeTypes.fragment) {\n      const children = filterIgnoreVirdNode(virdNode.children)\n      result.push(...children)\n    } else {\n      result.push(virdNode)\n    }\n  }\n\n  return result\n}\n\n/**\n * The render() function renders a VirdNode into a Dom.\n * @param rootNode A node to render.\n * @param virdNodes An array of VirdNode objects to render.\n */\nexport function render(rootNode: Node, ...virdNodes: VirdNode[]) {\n  for (const reserve of reserves) {\n    cancelAnimationFrame(reserve)\n  }\n  reserves.length = 0\n\n  const newVirdNodeLength = virdNodes.length\n  if (newVirdNodeLength < 1) return\n\n  // Create a VirdNode for rendering.\n  const clone = (virdNode: VirdNode) => cloneNode(virdNode, true)\n  const cloneVirdNodes = virdNodes.map(clone)\n  const newVirdNodes = filterIgnoreVirdNode(cloneVirdNodes)\n\n  // rendering.\n  diffRender(rootNode, newVirdNodes)\n}\n"],"names":[],"mappings":"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"}