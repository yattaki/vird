{"version":3,"file":"index.cjs.min.js","sources":["../src/vird/vird-event.ts","../src/vird-node/vird-node-types.ts","../src/create-node/create-node-from-string.ts","../src/create-node/clone-node.ts","../src/create-node/create-node.ts","../src/create-node/create-node-from-node.ts","../src/vird/vird-properties.ts","../src/renderer/reserve.ts","../src/renderer/update-attributes.ts","../src/renderer/vird-dom.ts","../src/renderer/create-real-node.ts","../src/renderer/diff.ts","../src/renderer/diff-render.ts","../src/renderer/render.ts"],"sourcesContent":["import { VirdNode } from '../vird-node/vird-node'\n\nexport type VirdEventProperties = {\n  [K in keyof HTMLElementEventMap]: VirdEventValue<K> | string\n}\n\nexport type VirdEventValue<K extends string = string> =\n  | VirdEventListener<K>\n  | {\n      listener: VirdEventListener<K>\n      options: VirdEventListenerOptions\n    }\n\nexport type VirdEventListener<K extends string = string> = (\n  event: K extends keyof HTMLElementEventMap ? HTMLElementEventMap[K] : Event\n) => boolean | void\n\nexport type VirdEventListenerOptions =\n  | AddEventListenerOptions\n  | boolean\n  | undefined\n\nconst virdEventListenerMap: WeakMap<\n  VirdNode,\n  Map<string, Set<VirdEventListener<any>>>\n> = new WeakMap()\n\nconst listenerOptionsMap: WeakMap<\n  VirdEventListener<any>,\n  VirdEventListenerOptions\n> = new WeakMap()\n\nexport function addVirdEvent<K extends string>(\n  virdNode: VirdNode,\n  type: K,\n  listener: VirdEventListener<K>,\n  options?: VirdEventListenerOptions\n) {\n  let eventListenerMap = virdEventListenerMap.get(virdNode)\n  if (!eventListenerMap) {\n    eventListenerMap = new Map()\n    virdEventListenerMap.set(virdNode, eventListenerMap)\n  }\n\n  let events = eventListenerMap.get(type)\n  if (!events) {\n    events = new Set()\n    eventListenerMap.set(type, events)\n  }\n\n  events.add(listener)\n  listenerOptionsMap.set(listener, options)\n}\n\nexport function removeVirdEvent<K extends string>(\n  virdNode: VirdNode,\n  type: K,\n  listener: VirdEventListener<K>\n) {\n  const eventListenerMap = virdEventListenerMap.get(virdNode)\n  if (!eventListenerMap) return\n\n  const events = eventListenerMap.get(type)\n  if (!events) return\n\n  events.delete(listener)\n  listenerOptionsMap.delete(listener)\n}\n\nexport function clearVirdEvent(virdEvent: VirdNode) {\n  virdEventListenerMap.delete(virdEvent)\n}\n\nexport function cloneVirdEvent(\n  copyVirdNode: VirdNode,\n  masterVirdNode: VirdNode\n) {\n  const eventListenerMap = virdEventListenerMap.get(masterVirdNode)\n  if (!eventListenerMap) return\n\n  for (const [key, events] of eventListenerMap) {\n    for (const event of events) {\n      addVirdEvent(copyVirdNode, key, event)\n    }\n  }\n}\n\nexport function onEvent(node: Node, virdNode: VirdNode) {\n  const eventListenerMap = virdEventListenerMap.get(virdNode)\n  if (eventListenerMap) {\n    for (const [name, eventMap] of eventListenerMap) {\n      for (const listener of eventMap) {\n        node.addEventListener(name, listener, listenerOptionsMap.get(listener))\n      }\n    }\n  }\n}\n\nexport function offEvent(node: Node, virdNode: VirdNode) {\n  const eventListenerMap = virdEventListenerMap.get(virdNode)\n  if (eventListenerMap) {\n    for (const [name, eventMap] of eventListenerMap) {\n      for (const listener of eventMap) {\n        node.removeEventListener(name, listener)\n      }\n    }\n  }\n}\n","/** A type list with a special meaning in the VirdNode element. */\nexport interface VirdNodeTypes {\n  /** An string representing the VirdNodeText. */\n  readonly text: '#text'\n  /** An object representing the VirdNodeComment. */\n  readonly comment: '#comment'\n  /** An object representing the VirdNodeFragment. */\n  readonly fragment: '#document-fragment'\n}\n\nexport const virdNodeTypes: VirdNodeTypes = {\n  text: '#text',\n  comment: '#comment',\n  fragment: '#document-fragment'\n}\n","import {\n  VirdCommentNode,\n  VirdFragmentNode,\n  VirdNode,\n  VirdTextNode\n} from '../vird-node/vird-node'\nimport { virdNodeTypes } from '../vird-node/vird-node-types'\n\n/**\n * This createNodeFromString() function creates a VirdNode from a string.\n * @param type A string that represents the type of VirdNode to create.\n * @param properties An object that represents the properties of the VirdNode to create.\n * @param children An array that represents the child nodes of the VirdNode to create.\n */\nexport function createNodeFromString(\n  type: VirdTextNode['type'],\n  properties?: VirdTextNode['properties'],\n  children?: VirdTextNode['children']\n): VirdTextNode\nexport function createNodeFromString(\n  type: VirdCommentNode['type'],\n  properties?: VirdCommentNode['properties'],\n  children?: VirdCommentNode['children']\n): VirdCommentNode\nexport function createNodeFromString(\n  type: VirdFragmentNode['type'],\n  properties?: VirdFragmentNode['properties'],\n  children?: VirdFragmentNode['children']\n): VirdFragmentNode\nexport function createNodeFromString(\n  type: string,\n  properties?: VirdNode['properties'],\n  children?: VirdNode['children']\n): VirdNode\nexport function createNodeFromString(\n  type: string,\n  properties: VirdNode['properties'] = {},\n  children: VirdNode['children'] = []\n) {\n  type = type.toLocaleLowerCase()\n  properties = { ...properties }\n  children = [...children]\n\n  if (\n    !properties.textContent &&\n    (virdNodeTypes.text === type || virdNodeTypes.comment === type)\n  ) {\n    properties.textContent = ''\n  }\n\n  return { type, properties, children } as VirdNode\n}\n","import { VirdNode } from '../vird-node/vird-node'\nimport { cloneVirdEvent } from '../vird/vird-event'\nimport { createNodeFromString } from './create-node-from-string'\n\n/**\n * The options object specifies the replication characteristics.\n */\nexport interface CloneNodeOptions {\n  /**\n   * A boolean that recursively duplicates child nodes.\n   * If true, the node and its entire subtree are also copied.\n   * Initial value is false.\n   */\n  deep: boolean\n  /**\n   * A boolean that recursively duplicates the events.\n   * If true, apply the event registered in the node to the copy destination as well.\n   * Initial value is false.\n   */\n  event: boolean\n}\n\n/**\n * This cloneNode() function duplicates VirdNode.\n * @param virdNode VirdNode to duplicate.\n * @param options\n */\nexport function cloneNode<R extends VirdNode>(\n  virdNode: VirdNode,\n  options: Partial<CloneNodeOptions> | boolean = {}\n): R {\n  if (typeof options === 'boolean') {\n    options = { deep: options, event: options }\n  }\n\n  const { deep = false, event = false } = options\n\n  const type = virdNode.type\n  const properties = { ...virdNode.properties }\n  const children = deep\n    ? virdNode.children.map(child => cloneNode(child, options))\n    : []\n\n  const cloneVirdNode = createNodeFromString(type, properties, children)\n\n  if (event) {\n    cloneVirdEvent(cloneVirdNode, virdNode)\n  }\n\n  return cloneVirdNode as R\n}\n","import {\n  ToVirdNode,\n  VirdCommentNode,\n  VirdFragmentNode,\n  VirdNode,\n  VirdTextNode\n} from '../vird-node/vird-node'\nimport { VirdNodeTypes, virdNodeTypes } from '../vird-node/vird-node-types'\nimport { addVirdEvent } from '../vird/vird-event'\nimport { parseVirdProperties, VirdProperties } from '../vird/vird-properties'\nimport { cloneNode } from './clone-node'\nimport { createNodeFromNode } from './create-node-from-node'\nimport { createNodeFromString } from './create-node-from-string'\n\n/**\n * This createNode() function creates a VirdNode.\n * @param base The base item for the created VirdNode.\n * @param properties An objects representing the VirdNode properties to create.\n */\nexport function createNode<\n  T extends\n    | VirdNodeTypes['text']\n    | VirdNodeTypes['comment']\n    | Text\n    | Comment\n    | VirdTextNode\n    | VirdCommentNode\n>(base: T, properties: ToVirdNode<T>['properties']): ToVirdNode<T>\n\n/**\n * This createNode() function creates a VirdNode.\n * @param base The base item for the created VirdNode.\n * @param text The string assigned to the value of virdTextNode.properties.textContent.\n */\nexport function createNode<\n  T extends\n    | VirdNodeTypes['text']\n    | VirdNodeTypes['comment']\n    | Text\n    | Comment\n    | VirdTextNode\n    | VirdCommentNode\n>(base: T, text?: string): ToVirdNode<T>\n\n/**\n * This createNode() function creates a VirdNode.\n * @param base The base item for the created VirdNode.\n * @param trim\n * A Boolean value that specifies the removal of elements that do not significantly affect the rendering.\n * If true, remove comments and text elements containing only spaces and line breaks.\n */\nexport function createNode<\n  T extends VirdNodeTypes['fragment'] | DocumentFragment | VirdFragmentNode\n>(base: T, trim: boolean): ToVirdNode<T>\n\n/**\n * This createNode() function creates a VirdNode.\n * @param base The base item for the created VirdNode.\n * @param children An array or string that represents the children of the VirdNode.\n * @param trim\n * A Boolean value that specifies the removal of elements that do not significantly affect the rendering.\n * If true, remove comments and text elements containing only spaces and line breaks.\n */\nexport function createNode<\n  T extends VirdNodeTypes['fragment'] | DocumentFragment | VirdFragmentNode\n>(\n  base: T,\n  children: string | (string | VirdNode)[],\n  trim?: boolean\n): ToVirdNode<T>\n\n/**\n * This createNode() function creates a VirdNode.\n * @param base The base item for the created VirdNode.\n * @param childrenOrTrim Argument that can choose one of these.\n * - children : An array or string that represents the children of the VirdNode.\n * - trim : A Boolean value that specifies the removal of elements that do not significantly affect the rendering.\n * If true, remove comments and text elements containing only spaces and line breaks.\n */\nexport function createNode<\n  T extends VirdNodeTypes['fragment'] | DocumentFragment | VirdFragmentNode\n>(\n  base: T,\n  childrenOrTrim?: string | (string | VirdNode)[] | boolean\n): ToVirdNode<T>\n\n/**\n * This createNode() function creates a VirdNode.\n * @param base The base item for the created VirdNode.\n * @param properties An objects representing the VirdNode properties to create.\n * @param children An array or string that represents the children of the VirdNode.\n * @param trim\n * A Boolean value that specifies the removal of elements that do not significantly affect the rendering.\n * If true, remove comments and text elements containing only spaces and line breaks.\n */\nexport function createNode<T extends string | Node | VirdNode>(\n  base: T,\n  properties: Partial<VirdProperties>,\n  children: string | (string | VirdNode)[],\n  trim?: boolean\n): ToVirdNode<T>\n\n/**\n * This createNode() function creates a VirdNode.\n * @param base The base item for the created VirdNode.\n * @param properties An objects representing the VirdNode properties to create.\n * @param trim\n * A Boolean value that specifies the removal of elements that do not significantly affect the rendering.\n * If true, remove comments and text elements containing only spaces and line breaks.\n */\nexport function createNode<T extends string | Node | VirdNode>(\n  base: T,\n  properties: Partial<VirdProperties>,\n  trim: boolean\n): ToVirdNode<T>\n\n/**\n * This createNode() function creates a VirdNode.\n * @param base The base item for the created VirdNode.\n * @param children An array or string that represents the children of the VirdNode.\n * @param trim\n * A Boolean value that specifies the removal of elements that do not significantly affect the rendering.\n * If true, remove comments and text elements containing only spaces and line breaks.\n */\nexport function createNode<T extends string | Node | VirdNode>(\n  base: T,\n  children: string | (string | VirdNode)[],\n  trim?: boolean\n): ToVirdNode<T>\n\n/**\n * This createNode() function creates a VirdNode.\n * @param base The base item for the created VirdNode.\n * @param trim\n * A Boolean value that specifies the removal of elements that do not significantly affect the rendering.\n * If true, remove comments and text elements containing only spaces and line breaks.\n */\nexport function createNode<T extends string | Node | VirdNode>(\n  base: T,\n  trim: boolean\n): ToVirdNode<T>\n\n/**\n * This createNode() function creates a VirdNode.\n * @param base The base item for the created VirdNode.\n * @param properties An objects representing the VirdNode properties to create.\n * @param childrenOrTrim Argument that can choose one of these.\n * - children : An array or string that represents the children of the VirdNode.\n * - trim : A Boolean value that specifies the removal of elements that do not significantly affect the rendering.\n * If true, remove comments and text elements containing only spaces and line breaks.\n */\nexport function createNode<T extends string | Node | VirdNode>(\n  base: T,\n  properties: Partial<VirdProperties>,\n  childrenOrTrim?: string | (string | VirdNode)[] | boolean\n): ToVirdNode<T>\n\n/**\n * This createNode() function creates a VirdNode.\n * @param base The base item for the created VirdNode.\n * @param propertiesOrChildrenOrTrim Argument that can choose one of these.\n * - properties : An objects representing the VirdNode properties to create.\n * - children : An array or string that represents the children of the VirdNode.\n * - trim : A Boolean value that specifies the removal of elements that do not significantly affect the rendering.\n * If true, remove comments and text elements containing only spaces and line breaks.\n */\nexport function createNode<T extends string | Node | VirdNode>(\n  base: T,\n  propertiesOrChildrenOrTrim?:\n    | Partial<VirdProperties>\n    | string\n    | (string | VirdNode)[]\n    | boolean\n): ToVirdNode<T>\n\n/**\n * This createNode() function creates a VirdNode.\n * @param base The base item for the created VirdNode.\n * @param propertiesOrChildrenOrTrim Argument that can choose one of these.\n * - properties : An objects representing the VirdNode properties to create.\n * - children : An array or string that represents the children of the VirdNode.\n * - trim : A Boolean value that specifies the removal of elements that do not significantly affect the rendering.\n * If true, remove comments and text elements containing only spaces and line breaks.\n * @param childrenOrTrim Argument that can choose one of these.\n * - children : An array or string that represents the children of the VirdNode.\n * - trim : A Boolean value that specifies the removal of elements that do not significantly affect the rendering.\n * If true, remove comments and text elements containing only spaces and line breaks.\n * @param trim\n * A Boolean value that specifies the removal of elements that do not significantly affect the rendering.\n * If true, remove comments and text elements containing only spaces and line breaks.\n */\nexport function createNode<T extends string | Node | VirdNode>(\n  base: T,\n  propertiesOrChildrenOrTrim?:\n    | Partial<VirdProperties>\n    | string\n    | (string | VirdNode)[]\n    | boolean,\n  childrenOrTrim?: string | (string | VirdNode)[] | boolean,\n  trim?: boolean\n): ToVirdNode<T>\n\nexport function createNode<T extends string | Node | VirdNode>(\n  base: T,\n  propertiesOrChildrenOrTrim?:\n    | Partial<VirdProperties>\n    | string\n    | (string | VirdNode)[]\n    | boolean,\n  childrenOrTrim?: string | (string | VirdNode)[] | boolean,\n  trim?: boolean\n): ToVirdNode<T> {\n  // create virdNode\n  const virdNode =\n    typeof base === 'string'\n      ? createNodeFromString(base)\n      : base instanceof Node\n      ? createNodeFromNode(base, true)\n      : cloneNode(base as VirdNode, { deep: true })\n\n  // add properties\n  if (\n    typeof propertiesOrChildrenOrTrim === 'object' &&\n    !Array.isArray(propertiesOrChildrenOrTrim)\n  ) {\n    const { events, properties } = parseVirdProperties(\n      propertiesOrChildrenOrTrim\n    )\n\n    virdNode.properties = {\n      ...virdNode.properties,\n      ...properties\n    }\n\n    // add events\n    for (const key of Object.keys(events)) {\n      const value = events[key]\n      if (typeof value === 'function') {\n        addVirdEvent(virdNode, key, value)\n      } else {\n        addVirdEvent(virdNode, key, value.listener, value.options)\n      }\n    }\n  } else if (propertiesOrChildrenOrTrim !== undefined) {\n    childrenOrTrim = propertiesOrChildrenOrTrim\n  }\n\n  // add children\n  if (typeof childrenOrTrim === 'string') {\n    const lastTypes: string[] = [virdNodeTypes.text, virdNodeTypes.comment]\n    if (lastTypes.includes(virdNode.type)) {\n      virdNode.properties.textContent = childrenOrTrim\n    } else {\n      virdNode.children = [\n        createNodeFromString('#text', { textContent: childrenOrTrim })\n      ]\n    }\n  } else if (Array.isArray(childrenOrTrim)) {\n    virdNode.children = childrenOrTrim.map(stringOrVirdNode => {\n      return typeof stringOrVirdNode === 'string'\n        ? createNodeFromString('#text', { textContent: stringOrVirdNode })\n        : stringOrVirdNode\n    })\n  } else if (childrenOrTrim !== undefined) {\n    trim = childrenOrTrim\n  }\n\n  // trimming\n  if (trim) {\n    virdNode.children = virdNode.children.filter(child => {\n      if (child.type === virdNodeTypes.comment) return false\n      if (child.type === virdNodeTypes.text) {\n        if (child.properties.textContent === undefined) return false\n        if (!/^\\s*$/.test(child.properties.textContent)) return false\n      }\n\n      return true\n    })\n  }\n\n  return virdNode as ToVirdNode<T>\n}\n","import {\n  VirdCommentNode,\n  VirdFragmentNode,\n  VirdNode,\n  VirdTextNode\n} from '../vird-node/vird-node'\nimport { createNodeFromString } from './create-node-from-string'\n\n/**\n * This createNodeFromNode() function creates a VirdNode from a Node.\n * @param node\n * A Node is used when creating a VirdNode.\n * The type of VirdNode created is the nodeName property converted to lowercase.\n */\nexport function createNodeFromNode(node: Text): VirdTextNode\nexport function createNodeFromNode(node: Comment): VirdCommentNode\n\n/**\n * This createNodeFromNode() function creates a VirdNode from a Node.\n * @param node\n * A Node is used when creating a VirdNode.\n * The type of VirdNode created is the nodeName property converted to lowercase.\n * @param deep\n * A boolean that recursively duplicates child nodes.\n * If true, the node and its entire subtree are also transformed.\n * Initial value is false.\n */\nexport function createNodeFromNode(\n  node: DocumentFragment,\n  deep: boolean\n): VirdFragmentNode\nexport function createNodeFromNode(node: Node, deep?: boolean): VirdNode\nexport function createNodeFromNode(node: Node, deep = false): VirdNode {\n  const type = node.nodeName\n  const properties: VirdNode['properties'] = {}\n\n  if (node instanceof Element) {\n    for (const { name, value } of node.attributes) {\n      properties[name] = value\n    }\n\n    if ('value' in node) {\n      properties.value = (node as HTMLInputElement).value\n    }\n  } else if (node instanceof Comment || node instanceof Text) {\n    properties.textContent = node.textContent || ''\n  }\n\n  const mapCallback = (child: Node) => createNodeFromNode(child, deep)\n  const children: VirdNode[] = deep ? [...node.childNodes].map(mapCallback) : []\n\n  return createNodeFromString(type, properties, children)\n}\n","import { VirdNode } from '../vird-node/vird-node'\nimport { VirdEventProperties, VirdEventValue } from './vird-event'\n\nexport type VirdProperties = {\n  [K in string]: VirdEventValue<K> | string\n} &\n  VirdEventProperties\n\nexport interface ParseVirdPropertiesResult {\n  events: { [key: string]: VirdEventValue }\n  properties: VirdNode['properties']\n}\n\nexport function parseVirdProperties(params: Partial<VirdProperties>) {\n  const result: ParseVirdPropertiesResult = {\n    events: {},\n    properties: {}\n  }\n\n  for (const key of Object.keys(params)) {\n    const value = params[key]\n\n    if (typeof value === 'string') {\n      result.properties[key] = value\n    } else if (value) {\n      result.events[key] = value\n    }\n  }\n\n  return result\n}\n","export const reserves: number[] = []\n","export function updateAttribute(\n  element: Element,\n  name: string,\n  value?: string | number | boolean | string[] | null\n) {\n  if (value != null) {\n    const attrValue = Array.isArray(value) ? value.join(' ') : String(value)\n\n    switch (name) {\n      case 'value':\n        ;(element as HTMLInputElement).value = attrValue\n        break\n\n      default:\n        element.setAttribute(name, attrValue)\n        break\n    }\n  } else {\n    element.removeAttribute(name)\n  }\n}\n","import { VirdNode } from '../vird-node/vird-node'\n\nexport const virdDom: WeakMap<Node, VirdNode[]> = new WeakMap()\nexport const nodeMap: WeakMap<VirdNode, Node> = new WeakMap()\n","import { cloneNode } from '../create-node/clone-node'\nimport { VirdNode } from '../vird-node/vird-node'\nimport { virdNodeTypes } from '../vird-node/vird-node-types'\nimport { onEvent } from '../vird/vird-event'\nimport { reserves } from './reserve'\nimport { updateAttribute } from './update-attributes'\nimport { nodeMap, virdDom } from './vird-dom'\n\nfunction createElement(virdNode: VirdNode) {\n  const element = document.createElement(virdNode.type)\n\n  for (const name of Object.keys(virdNode.properties)) {\n    updateAttribute(element, name, virdNode.properties[name])\n  }\n\n  onEvent(element, virdNode)\n\n  const clone = (virdNode: VirdNode) => cloneNode(virdNode, true)\n  const cloneVirdNodes = virdNode.children.map(clone)\n\n  const fragment = document.createDocumentFragment()\n  for (const child of cloneVirdNodes) {\n    const childNode = createRealNode(child)\n    fragment.appendChild(childNode)\n  }\n\n  const renderingReserve = requestAnimationFrame(() => {\n    element.appendChild(fragment)\n    virdDom.set(element, cloneVirdNodes)\n  })\n  reserves.push(renderingReserve)\n\n  return element\n}\n\n/**\n * The createRealNode() function creates a node from VirdNode.\n * @param virdNode The VirdNode object from which it is created.\n */\nexport function createRealNode(virdNode: VirdNode) {\n  let node: Node\n  switch (virdNode.type) {\n    case virdNodeTypes.text:\n      node = document.createTextNode(virdNode.properties.textContent || '')\n      break\n    case virdNodeTypes.comment:\n      node = document.createComment(virdNode.properties.textContent || '')\n      break\n    default:\n      node = createElement(virdNode)\n  }\n\n  nodeMap.set(virdNode, node)\n\n  return node\n}\n","type DiffObject<T extends { [key: string]: any }> = {\n  [K in keyof T]?: [T[K] | undefined, T[K] | undefined]\n}\n\n/**\n * The diff () function gets the diff of an object.\n * @param checkObject An object to compare the differences.\n * @param comparisonObjet An object to compare.\n */\nexport function diff<T = { [key: string]: any }>(\n  checkObject?: T | undefined,\n  comparisonObjet?: T | undefined\n) {\n  const diffObject = {} as DiffObject<T>\n\n  if (checkObject !== comparisonObjet) {\n    if (checkObject) {\n      const checkObjectKey = Object.keys(checkObject) as (keyof T)[]\n      if (comparisonObjet) {\n        const comparisonObjetKey = Object.keys(comparisonObjet) as (keyof T)[]\n        const keys: Set<keyof T> = new Set([\n          ...checkObjectKey,\n          ...comparisonObjetKey\n        ])\n\n        for (const key of keys) {\n          const checkObjetValue = checkObject[key]\n          const comparisonObjetValue = comparisonObjet[key]\n          if (checkObjetValue === comparisonObjetValue) {\n            continue\n          }\n\n          diffObject[key] = [checkObjetValue, comparisonObjetValue]\n        }\n      } else {\n        for (const key of checkObjectKey) {\n          const value = checkObject[key]\n          diffObject[key] = [value, undefined]\n        }\n      }\n    } else {\n      if (comparisonObjet) {\n        const comparisonObjetKey = Object.keys(comparisonObjet) as (keyof T)[]\n        for (const key of comparisonObjetKey) {\n          const value = comparisonObjet[key]\n          diffObject[key] = [undefined, value]\n        }\n      }\n    }\n  }\n\n  return diffObject\n}\n","import { createNode } from '../create-node/create-node'\nimport { VirdNode } from '../vird-node/vird-node'\nimport { clearVirdEvent, offEvent, onEvent } from '../vird/vird-event'\nimport { createRealNode } from './create-real-node'\nimport { diff } from './diff'\nimport { updateAttribute } from './update-attributes'\nimport { nodeMap, virdDom } from './vird-dom'\n\nfunction removeVirdDom(node: Node) {\n  virdDom.delete(node)\n  for (const childNode of node.childNodes) {\n    removeVirdDom(childNode)\n  }\n}\n\nexport function diffRender(rootNode: Node, newVirdNodes: VirdNode[]) {\n  const oldVirdNodes =\n    virdDom.get(rootNode) ||\n    [...rootNode.childNodes].map(child => createNode(child))\n\n  let index = 0\n  let newVirdNodeIndex = 0\n  let oldVirdNodeIndex = 0\n  const newVirdNodeLength = newVirdNodes.length\n  const oldVirdNodeLength = oldVirdNodes.length\n  const maxIndex = Math.max(newVirdNodeLength, oldVirdNodeLength)\n\n  while (index < maxIndex) {\n    const newVirdNode = newVirdNodes[newVirdNodeIndex] as VirdNode | undefined\n    const oldVirdNode = oldVirdNodes[oldVirdNodeIndex] as VirdNode | undefined\n    const oldNode = oldVirdNode && nodeMap.get(oldVirdNode)\n\n    if (newVirdNode) {\n      if (!oldVirdNode || oldVirdNode.type !== newVirdNode.type) {\n        const realNode = createRealNode(newVirdNode)\n\n        if (oldNode) {\n          removeVirdDom(oldNode)\n          const parent = oldNode.parentElement\n          if (parent === rootNode) {\n            if (newVirdNodeLength > oldVirdNodeLength) {\n              parent.insertBefore(realNode, oldNode)\n              oldVirdNodeIndex--\n            } else if (newVirdNodeLength < oldVirdNodeLength) {\n              parent.removeChild(oldNode)\n              newVirdNodeIndex--\n            } else {\n              parent.replaceChild(realNode, oldNode)\n            }\n          }\n        } else {\n          rootNode.appendChild(realNode)\n        }\n      } else if (oldNode) {\n        nodeMap.delete(oldVirdNode)\n        nodeMap.set(newVirdNode, oldNode)\n\n        const diffProperties = diff(\n          newVirdNode.properties,\n          oldVirdNode.properties\n        )\n\n        if (oldNode instanceof Element) {\n          for (const name of Object.keys(diffProperties)) {\n            const newValue = diffProperties[name]\n            const value = newValue && newValue[0]\n\n            updateAttribute(oldNode, name, value)\n          }\n\n          if (oldVirdNode) {\n            offEvent(oldNode, oldVirdNode)\n            clearVirdEvent(oldVirdNode)\n          }\n\n          onEvent(oldNode, newVirdNode)\n        } else {\n          if (diffProperties.textContent) {\n            oldNode.textContent = diffProperties.textContent[0] || ''\n          }\n        }\n\n        diffRender(oldNode, newVirdNode.children)\n      }\n    } else if (oldNode) {\n      const parent = oldNode.parentElement\n      if (parent) {\n        parent.removeChild(oldNode)\n      }\n    }\n\n    index++\n    newVirdNodeIndex++\n    oldVirdNodeIndex++\n  }\n\n  virdDom.set(rootNode, newVirdNodes)\n}\n","import { cloneNode } from '../create-node/clone-node'\nimport { VirdNode } from '../vird-node/vird-node'\nimport { virdNodeTypes } from '../vird-node/vird-node-types'\nimport { diffRender } from './diff-render'\nimport { reserves } from './reserve'\n\nfunction filterIgnoreVirdNode(virdNodes: VirdNode[]) {\n  const result: VirdNode[] = []\n\n  for (const virdNode of virdNodes) {\n    if (virdNode.type === virdNodeTypes.fragment) {\n      const children = filterIgnoreVirdNode(virdNode.children)\n      result.push(...children)\n    } else {\n      result.push(virdNode)\n    }\n  }\n\n  return result\n}\n\n/**\n * The render() function renders a VirdNode into a Dom.\n * @param rootNode A node to render.\n * @param virdNodes An array of VirdNode objects to render.\n */\nexport function render(rootNode: Node, ...virdNodes: VirdNode[]) {\n  for (const reserve of reserves) {\n    cancelAnimationFrame(reserve)\n  }\n  reserves.length = 0\n\n  const newVirdNodeLength = virdNodes.length\n  if (newVirdNodeLength < 1) return\n\n  // Create a VirdNode for rendering.\n  const clone = (virdNode: VirdNode) => cloneNode(virdNode, true)\n  const cloneVirdNodes = virdNodes.map(clone)\n  const newVirdNodes = filterIgnoreVirdNode(cloneVirdNodes)\n\n  // rendering.\n  diffRender(rootNode, newVirdNodes)\n}\n"],"names":["virdEventListenerMap","WeakMap","listenerOptionsMap","addVirdEvent","virdNode","type","listener","options","eventListenerMap","get","Map","set","events","Set","add","onEvent","node","name","eventMap","addEventListener","offEvent","removeEventListener","virdNodeTypes","createNodeFromString","properties","children","toLocaleLowerCase","textContent","cloneNode","deep","event","cloneVirdNode","map","child","copyVirdNode","masterVirdNode","key","cloneVirdEvent","createNode","base","propertiesOrChildrenOrTrim","childrenOrTrim","trim","Node","createNodeFromNode","nodeName","Element","value","attributes","Comment","Text","childNodes","Array","isArray","undefined","params","result","Object","keys","parseVirdProperties","includes","stringOrVirdNode","filter","test","reserves","updateAttribute","element","attrValue","join","String","setAttribute","removeAttribute","virdDom","nodeMap","createRealNode","document","createTextNode","createComment","createElement","cloneVirdNodes","fragment","createDocumentFragment","childNode","appendChild","renderingReserve","requestAnimationFrame","push","diff","checkObject","comparisonObjet","diffObject","checkObjectKey","comparisonObjetKey","checkObjetValue","comparisonObjetValue","removeVirdDom","delete","rootNode","virdNodes","reserve","cancelAnimationFrame","length","diffRender","newVirdNodes","oldVirdNodes","index","newVirdNodeIndex","oldVirdNodeIndex","newVirdNodeLength","oldVirdNodeLength","maxIndex","Math","max","newVirdNode","oldVirdNode","oldNode","diffProperties","newValue","virdEvent","realNode","parent","parentElement","insertBefore","removeChild","replaceChild","filterIgnoreVirdNode"],"mappings":"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"}