{"version":3,"file":"index.umd.js","sources":["../src/vird/vird-event.ts","../src/vird-node/vird-node-types.ts","../src/create-node/create-node-from-string.ts","../src/create-node/clone-node.ts","../src/vird/vird-properties.ts","../src/create-node/create-node-from-node.ts","../src/create-node/create-node.ts","../src/renderer/create-real-node.ts","../src/renderer/diff.ts","../src/renderer/diff-render.ts","../src/renderer/render.ts"],"sourcesContent":["import { VirdNode } from '../vird-node/vird-node'\n\nexport type VirdEventProperties = {\n  [K in keyof HTMLElementEventMap]: VirdEventValue<K> | string\n}\n\nexport type VirdEventValue<K extends string = string> =\n  | VirdEventListener<K>\n  | {\n      listener: VirdEventListener<K>\n      options: VirdEventListenerOptions\n    }\n\nexport type VirdEventListener<K extends string = string> = (\n  event: K extends keyof HTMLElementEventMap ? HTMLElementEventMap[K] : Event\n) => boolean | void\n\nexport type VirdEventListenerOptions =\n  | AddEventListenerOptions\n  | boolean\n  | undefined\n\nconst virdEventListenerMap: WeakMap<\n  VirdNode,\n  Map<string, Set<VirdEventListener<any>>>\n> = new WeakMap()\n\nconst listenerOptionsMap: WeakMap<\n  VirdEventListener<any>,\n  VirdEventListenerOptions\n> = new WeakMap()\n\nexport function addVirdEvent<K extends string>(\n  virdNode: VirdNode,\n  type: K,\n  listener: VirdEventListener<K>,\n  options?: VirdEventListenerOptions\n) {\n  let eventListenerMap = virdEventListenerMap.get(virdNode)\n  if (!eventListenerMap) {\n    eventListenerMap = new Map()\n    virdEventListenerMap.set(virdNode, eventListenerMap)\n  }\n\n  let events = eventListenerMap.get(type)\n  if (!events) {\n    events = new Set()\n    eventListenerMap.set(type, events)\n  }\n\n  events.add(listener)\n  listenerOptionsMap.set(listener, options)\n}\n\nexport function removeVirdEvent<K extends string>(\n  virdNode: VirdNode,\n  type: K,\n  listener: VirdEventListener<K>\n) {\n  const eventListenerMap = virdEventListenerMap.get(virdNode)\n  if (!eventListenerMap) return\n\n  const events = eventListenerMap.get(type)\n  if (!events) return\n\n  events.delete(listener)\n  listenerOptionsMap.delete(listener)\n}\n\nexport function getVirdEventMap(virdNode: VirdNode) {\n  const result: {\n    [key: string]: {\n      listener: VirdEventListener\n      options: VirdEventListenerOptions\n    }[]\n  } = {}\n\n  const eventListenerMap = virdEventListenerMap.get(virdNode)\n  if (eventListenerMap) {\n    for (const [key, listeners] of eventListenerMap) {\n      result[key] = []\n      for (const listener of listeners) {\n        const options = listenerOptionsMap.get(listener)\n        result[key].push({ listener, options })\n      }\n    }\n  }\n\n  return result\n}\n\nexport function cloneVirdEvent(\n  copyVirdNode: VirdNode,\n  masterVirdNode: VirdNode\n) {\n  const eventListenerMap = virdEventListenerMap.get(masterVirdNode)\n  if (!eventListenerMap) return\n\n  for (const [key, events] of eventListenerMap) {\n    for (const event of events) {\n      addVirdEvent(copyVirdNode, key, event)\n    }\n  }\n}\n","/** A type list with a special meaning in the VirdNode element. */\nexport interface VirdNodeTypes {\n  /** An string representing the VirdNodeText. */\n  readonly text: '#text'\n  /** An object representing the VirdNodeComment. */\n  readonly comment: '#comment'\n  /** An object representing the VirdNodeFragment. */\n  readonly fragment: '#document-fragment'\n}\n\nexport const virdNodeTypes: VirdNodeTypes = {\n  text: '#text',\n  comment: '#comment',\n  fragment: '#document-fragment'\n}\n","import {\n  VirdCommentNode,\n  VirdFragmentNode,\n  VirdNode,\n  VirdTextNode\n} from '../vird-node/vird-node'\nimport { virdNodeTypes } from '../vird-node/vird-node-types'\n\n/**\n * This createNodeFromString() function creates a VirdNode from a string.\n * @param type A string that represents the type of VirdNode to create.\n * @param properties An object that represents the properties of the VirdNode to create.\n * @param children An array that represents the child nodes of the VirdNode to create.\n */\nexport function createNodeFromString(\n  type: VirdTextNode['type'],\n  properties?: VirdTextNode['properties'],\n  children?: VirdTextNode['children']\n): VirdTextNode\nexport function createNodeFromString(\n  type: VirdCommentNode['type'],\n  properties?: VirdCommentNode['properties'],\n  children?: VirdCommentNode['children']\n): VirdCommentNode\nexport function createNodeFromString(\n  type: VirdFragmentNode['type'],\n  properties?: VirdFragmentNode['properties'],\n  children?: VirdFragmentNode['children']\n): VirdFragmentNode\nexport function createNodeFromString(\n  type: string,\n  properties?: VirdNode['properties'],\n  children?: VirdNode['children']\n): VirdNode\nexport function createNodeFromString(\n  type: string,\n  properties: VirdNode['properties'] = {},\n  children: VirdNode['children'] = []\n) {\n  type = type.toLocaleLowerCase()\n  properties = { ...properties }\n  children = [...children]\n\n  if (\n    !properties.textContent &&\n    (virdNodeTypes.text === type || virdNodeTypes.comment === type)\n  ) {\n    properties.textContent = ''\n  }\n\n  return { type, properties, children } as VirdNode\n}\n","import { VirdNode } from '../vird-node/vird-node'\nimport { cloneVirdEvent } from '../vird/vird-event'\nimport { createNodeFromString } from './create-node-from-string'\n\n/**\n * The options object specifies the replication characteristics.\n */\nexport interface CloneNodeOptions {\n  /**\n   * A boolean that recursively duplicates child nodes.\n   * If true, the node and its entire subtree are also copied.\n   * Initial value is false.\n   */\n  deep: boolean\n  /**\n   * A boolean that recursively duplicates the events.\n   * If true, apply the event registered in the node to the copy destination as well.\n   * Initial value is false.\n   */\n  event: boolean\n}\n\n/**\n * This cloneNode() function duplicates VirdNode.\n * @param virdNode VirdNode to duplicate.\n * @param options\n */\nexport function cloneNode<R extends VirdNode>(\n  virdNode: VirdNode,\n  options: Partial<CloneNodeOptions> | boolean = {}\n): R {\n  if (typeof options === 'boolean') {\n    options = { deep: options, event: options }\n  }\n\n  const { deep = false, event = false } = options\n\n  const type = virdNode.type\n  const properties = { ...virdNode.properties }\n  const children = deep\n    ? virdNode.children.map(child => cloneNode(child, options))\n    : []\n\n  const cloneVirdNode = createNodeFromString(type, properties, children)\n\n  if (event) {\n    cloneVirdEvent(cloneVirdNode, virdNode)\n  }\n\n  return cloneVirdNode as R\n}\n","import { VirdNode } from '../vird-node/vird-node'\nimport { VirdEventProperties, VirdEventValue } from './vird-event'\n\nexport type VirdProperties = {\n  [K in string]: VirdEventValue<K> | string\n} &\n  VirdEventProperties\n\nexport interface ParseVirdPropertiesResult {\n  events: { [key: string]: VirdEventValue }\n  properties: VirdNode['properties']\n}\n\nexport function parseVirdProperties(params: Partial<VirdProperties>) {\n  const result: ParseVirdPropertiesResult = {\n    events: {},\n    properties: {}\n  }\n\n  for (const key of Object.keys(params)) {\n    const value = params[key]\n\n    if (typeof value === 'string') {\n      result.properties[key] = value\n    } else if (value) {\n      result.events[key] = value\n    }\n  }\n\n  return result\n}\n","import {\n  VirdCommentNode,\n  VirdFragmentNode,\n  VirdNode,\n  VirdTextNode\n} from '../vird-node/vird-node'\nimport { createNodeFromString } from './create-node-from-string'\n\n/**\n * This createNodeFromNode() function creates a VirdNode from a Node.\n * @param node\n * A Node is used when creating a VirdNode.\n * The type of VirdNode created is the nodeName property converted to lowercase.\n */\nexport function createNodeFromNode(node: Text): VirdTextNode\nexport function createNodeFromNode(node: Comment): VirdCommentNode\n\n/**\n * This createNodeFromNode() function creates a VirdNode from a Node.\n * @param node\n * A Node is used when creating a VirdNode.\n * The type of VirdNode created is the nodeName property converted to lowercase.\n * @param deep\n * A boolean that recursively duplicates child nodes.\n * If true, the node and its entire subtree are also transformed.\n * Initial value is false.\n */\nexport function createNodeFromNode(\n  node: DocumentFragment,\n  deep: boolean\n): VirdFragmentNode\nexport function createNodeFromNode(node: Node, deep?: boolean): VirdNode\nexport function createNodeFromNode(node: Node, deep = false): VirdNode {\n  const type = node.nodeName\n  const properties: VirdNode['properties'] = {}\n\n  if (node instanceof Element) {\n    for (const { name, value } of node.attributes) {\n      properties[name] = value\n    }\n  } else if (node instanceof Comment || node instanceof Text) {\n    properties.textContent = node.textContent || ''\n  }\n\n  const mapCallback = (child: Node) => createNodeFromNode(child, deep)\n  const children: VirdNode[] = deep ? [...node.childNodes].map(mapCallback) : []\n\n  return createNodeFromString(type, properties, children)\n}\n","import {\n  ToVirdNode,\n  VirdCommentNode,\n  VirdFragmentNode,\n  VirdNode,\n  VirdTextNode\n} from '../vird-node/vird-node'\nimport { VirdNodeTypes, virdNodeTypes } from '../vird-node/vird-node-types'\nimport { addVirdEvent } from '../vird/vird-event'\nimport { parseVirdProperties, VirdProperties } from '../vird/vird-properties'\nimport { cloneNode } from './clone-node'\nimport { createNodeFromNode } from './create-node-from-node'\nimport { createNodeFromString } from './create-node-from-string'\n\n/**\n * This createNode() function creates a VirdNode.\n * @param base The base item for the created VirdNode.\n * @param properties An objects representing the VirdNode properties to create.\n */\nexport function createNode<\n  T extends\n    | VirdNodeTypes['text']\n    | VirdNodeTypes['comment']\n    | Text\n    | Comment\n    | VirdTextNode\n    | VirdCommentNode\n>(base: T, properties: ToVirdNode<T>['properties']): ToVirdNode<T>\n\n/**\n * This createNode() function creates a VirdNode.\n * @param base The base item for the created VirdNode.\n * @param text The string assigned to the value of virdTextNode.properties.textContent.\n */\nexport function createNode<\n  T extends\n    | VirdNodeTypes['text']\n    | VirdNodeTypes['comment']\n    | Text\n    | Comment\n    | VirdTextNode\n    | VirdCommentNode\n>(base: T, text?: string): ToVirdNode<T>\n\n/**\n * This createNode() function creates a VirdNode.\n * @param base The base item for the created VirdNode.\n * @param trim\n * A Boolean value that specifies the removal of elements that do not significantly affect the rendering.\n * If true, remove comments and text elements containing only spaces and line breaks.\n */\nexport function createNode<\n  T extends VirdNodeTypes['fragment'] | DocumentFragment | VirdFragmentNode\n>(base: T, trim: boolean): ToVirdNode<T>\n\n/**\n * This createNode() function creates a VirdNode.\n * @param base The base item for the created VirdNode.\n * @param children An array or string that represents the children of the VirdNode.\n * @param trim\n * A Boolean value that specifies the removal of elements that do not significantly affect the rendering.\n * If true, remove comments and text elements containing only spaces and line breaks.\n */\nexport function createNode<\n  T extends VirdNodeTypes['fragment'] | DocumentFragment | VirdFragmentNode\n>(\n  base: T,\n  children: string | (string | VirdNode)[],\n  trim?: boolean\n): ToVirdNode<T>\n\n/**\n * This createNode() function creates a VirdNode.\n * @param base The base item for the created VirdNode.\n * @param childrenOrTrim Argument that can choose one of these.\n * - children : An array or string that represents the children of the VirdNode.\n * - trim : A Boolean value that specifies the removal of elements that do not significantly affect the rendering.\n * If true, remove comments and text elements containing only spaces and line breaks.\n */\nexport function createNode<\n  T extends VirdNodeTypes['fragment'] | DocumentFragment | VirdFragmentNode\n>(\n  base: T,\n  childrenOrTrim?: string | (string | VirdNode)[] | boolean\n): ToVirdNode<T>\n\n/**\n * This createNode() function creates a VirdNode.\n * @param base The base item for the created VirdNode.\n * @param properties An objects representing the VirdNode properties to create.\n * @param children An array or string that represents the children of the VirdNode.\n * @param trim\n * A Boolean value that specifies the removal of elements that do not significantly affect the rendering.\n * If true, remove comments and text elements containing only spaces and line breaks.\n */\nexport function createNode<T extends string | Node | VirdNode>(\n  base: T,\n  properties: Partial<VirdProperties>,\n  children: string | (string | VirdNode)[],\n  trim?: boolean\n): ToVirdNode<T>\n\n/**\n * This createNode() function creates a VirdNode.\n * @param base The base item for the created VirdNode.\n * @param properties An objects representing the VirdNode properties to create.\n * @param trim\n * A Boolean value that specifies the removal of elements that do not significantly affect the rendering.\n * If true, remove comments and text elements containing only spaces and line breaks.\n */\nexport function createNode<T extends string | Node | VirdNode>(\n  base: T,\n  properties: Partial<VirdProperties>,\n  trim: boolean\n): ToVirdNode<T>\n\n/**\n * This createNode() function creates a VirdNode.\n * @param base The base item for the created VirdNode.\n * @param children An array or string that represents the children of the VirdNode.\n * @param trim\n * A Boolean value that specifies the removal of elements that do not significantly affect the rendering.\n * If true, remove comments and text elements containing only spaces and line breaks.\n */\nexport function createNode<T extends string | Node | VirdNode>(\n  base: T,\n  children: string | (string | VirdNode)[],\n  trim?: boolean\n): ToVirdNode<T>\n\n/**\n * This createNode() function creates a VirdNode.\n * @param base The base item for the created VirdNode.\n * @param trim\n * A Boolean value that specifies the removal of elements that do not significantly affect the rendering.\n * If true, remove comments and text elements containing only spaces and line breaks.\n */\nexport function createNode<T extends string | Node | VirdNode>(\n  base: T,\n  trim: boolean\n): ToVirdNode<T>\n\n/**\n * This createNode() function creates a VirdNode.\n * @param base The base item for the created VirdNode.\n * @param properties An objects representing the VirdNode properties to create.\n * @param childrenOrTrim Argument that can choose one of these.\n * - children : An array or string that represents the children of the VirdNode.\n * - trim : A Boolean value that specifies the removal of elements that do not significantly affect the rendering.\n * If true, remove comments and text elements containing only spaces and line breaks.\n */\nexport function createNode<T extends string | Node | VirdNode>(\n  base: T,\n  properties: Partial<VirdProperties>,\n  childrenOrTrim?: string | (string | VirdNode)[] | boolean\n): ToVirdNode<T>\n\n/**\n * This createNode() function creates a VirdNode.\n * @param base The base item for the created VirdNode.\n * @param propertiesOrChildrenOrTrim Argument that can choose one of these.\n * - properties : An objects representing the VirdNode properties to create.\n * - children : An array or string that represents the children of the VirdNode.\n * - trim : A Boolean value that specifies the removal of elements that do not significantly affect the rendering.\n * If true, remove comments and text elements containing only spaces and line breaks.\n */\nexport function createNode<T extends string | Node | VirdNode>(\n  base: T,\n  propertiesOrChildrenOrTrim?:\n    | Partial<VirdProperties>\n    | string\n    | (string | VirdNode)[]\n    | boolean\n): ToVirdNode<T>\n\n/**\n * This createNode() function creates a VirdNode.\n * @param base The base item for the created VirdNode.\n * @param propertiesOrChildrenOrTrim Argument that can choose one of these.\n * - properties : An objects representing the VirdNode properties to create.\n * - children : An array or string that represents the children of the VirdNode.\n * - trim : A Boolean value that specifies the removal of elements that do not significantly affect the rendering.\n * If true, remove comments and text elements containing only spaces and line breaks.\n * @param childrenOrTrim Argument that can choose one of these.\n * - children : An array or string that represents the children of the VirdNode.\n * - trim : A Boolean value that specifies the removal of elements that do not significantly affect the rendering.\n * If true, remove comments and text elements containing only spaces and line breaks.\n * @param trim\n * A Boolean value that specifies the removal of elements that do not significantly affect the rendering.\n * If true, remove comments and text elements containing only spaces and line breaks.\n */\nexport function createNode<T extends string | Node | VirdNode>(\n  base: T,\n  propertiesOrChildrenOrTrim?:\n    | Partial<VirdProperties>\n    | string\n    | (string | VirdNode)[]\n    | boolean,\n  childrenOrTrim?: string | (string | VirdNode)[] | boolean,\n  trim?: boolean\n): ToVirdNode<T>\n\nexport function createNode<T extends string | Node | VirdNode>(\n  base: T,\n  propertiesOrChildrenOrTrim?:\n    | Partial<VirdProperties>\n    | string\n    | (string | VirdNode)[]\n    | boolean,\n  childrenOrTrim?: string | (string | VirdNode)[] | boolean,\n  trim?: boolean\n): ToVirdNode<T> {\n  // create virdNode\n  const virdNode =\n    typeof base === 'string'\n      ? createNodeFromString(base)\n      : base instanceof Node\n      ? createNodeFromNode(base, true)\n      : cloneNode(base as VirdNode, { deep: true })\n\n  // add properties\n  if (\n    typeof propertiesOrChildrenOrTrim === 'object' &&\n    !Array.isArray(propertiesOrChildrenOrTrim)\n  ) {\n    const { events, properties } = parseVirdProperties(\n      propertiesOrChildrenOrTrim\n    )\n\n    virdNode.properties = {\n      ...virdNode.properties,\n      ...properties\n    }\n\n    // add events\n    for (const key of Object.keys(events)) {\n      const value = events[key]\n      if (typeof value === 'function') {\n        addVirdEvent(virdNode, key, value)\n      } else {\n        addVirdEvent(virdNode, key, value.listener, value.options)\n      }\n    }\n  } else if (propertiesOrChildrenOrTrim !== undefined) {\n    childrenOrTrim = propertiesOrChildrenOrTrim\n  }\n\n  // add children\n  if (typeof childrenOrTrim === 'string') {\n    const lastTypes: string[] = [virdNodeTypes.text, virdNodeTypes.comment]\n    if (lastTypes.includes(virdNode.type)) {\n      virdNode.properties.textContent = childrenOrTrim\n    } else {\n      virdNode.children = [\n        createNodeFromString('#text', { textContent: childrenOrTrim })\n      ]\n    }\n  } else if (Array.isArray(childrenOrTrim)) {\n    virdNode.children = childrenOrTrim.map(stringOrVirdNode => {\n      return typeof stringOrVirdNode === 'string'\n        ? createNodeFromString('#text', { textContent: stringOrVirdNode })\n        : stringOrVirdNode\n    })\n  } else if (childrenOrTrim !== undefined) {\n    trim = childrenOrTrim\n  }\n\n  // trimming\n  if (trim) {\n    virdNode.children = virdNode.children.filter(child => {\n      if (child.type === virdNodeTypes.comment) return false\n      if (child.type === virdNodeTypes.text) {\n        if (child.properties.textContent === undefined) return false\n        if (!/^\\s*$/.test(child.properties.textContent)) return false\n      }\n\n      return true\n    })\n  }\n\n  return virdNode as ToVirdNode<T>\n}\n","import { VirdNode } from '../vird-node/vird-node'\nimport { virdNodeTypes } from '../vird-node/vird-node-types'\n\nexport function createRealNode(virdNode: VirdNode) {\n  switch (virdNode.type) {\n    case virdNodeTypes.text:\n      return document.createTextNode(virdNode.properties.textContent || '')\n    case virdNodeTypes.comment:\n      return document.createComment(virdNode.properties.textContent || '')\n    default:\n      return document.createElement(virdNode.type)\n  }\n}\n","type DiffObject<T extends { [key: string]: any }> = {\n  [K in keyof T]?: [T[K] | undefined, T[K] | undefined]\n}\n\nexport function diff<T = { [key: string]: any }>(\n  checkObject?: T | undefined,\n  comparisonObjet?: T | undefined\n) {\n  const diffObject = {} as DiffObject<T>\n\n  if (checkObject !== comparisonObjet) {\n    if (checkObject) {\n      const checkObjectKey = Object.keys(checkObject) as (keyof T)[]\n      if (comparisonObjet) {\n        const comparisonObjetKey = Object.keys(comparisonObjet) as (keyof T)[]\n        const keys: Set<keyof T> = new Set([\n          ...checkObjectKey,\n          ...comparisonObjetKey\n        ])\n\n        for (const key of keys) {\n          const checkObjetValue = checkObject[key]\n          const comparisonObjetValue = comparisonObjet[key]\n          if (checkObjetValue === comparisonObjetValue) {\n            continue\n          }\n\n          diffObject[key] = [checkObjetValue, comparisonObjetValue]\n        }\n      } else {\n        for (const key of checkObjectKey) {\n          const value = checkObject[key]\n          diffObject[key] = [value, undefined]\n        }\n      }\n    } else {\n      if (comparisonObjet) {\n        const comparisonObjetKey = Object.keys(comparisonObjet) as (keyof T)[]\n        for (const key of comparisonObjetKey) {\n          const value = comparisonObjet[key]\n          diffObject[key] = [undefined, value]\n        }\n      }\n    }\n  }\n\n  return diffObject\n}\n","import { createNode } from '../create-node/create-node'\nimport { VirdNode } from '../vird-node/vird-node'\nimport { getVirdEventMap } from '../vird/vird-event'\nimport { createRealNode } from './create-real-node'\nimport { diff } from './diff'\n\nconst beforeVirdNodes: WeakMap<Node, VirdNode[]> = new WeakMap()\nconst nodeMap: WeakMap<VirdNode, Node> = new WeakMap()\nexport function diffRender(rootNode: Node, newVirdNodes: VirdNode[]) {\n  const oldVirdNodes =\n    beforeVirdNodes.get(rootNode) ||\n    [...rootNode.childNodes].map(child => createNode(child))\n\n  beforeVirdNodes.set(rootNode, newVirdNodes)\n\n  let index = 0\n  let newVirdNodeIndex = 0\n  let oldVirdNodeIndex = 0\n  const newVirdNodeLength = newVirdNodes.length\n  const oldVirdNodeLength = oldVirdNodes.length\n  const maxIndex = Math.max(newVirdNodeLength, oldVirdNodeLength)\n\n  while (index < maxIndex) {\n    const newVirdNode = newVirdNodes[newVirdNodeIndex] as VirdNode | undefined\n    const oldVirdNode = oldVirdNodes[oldVirdNodeIndex] as VirdNode | undefined\n    const oldNode = oldVirdNode && nodeMap.get(oldVirdNode)\n\n    if (newVirdNode) {\n      let nextNode = oldNode\n      if (!oldVirdNode || oldVirdNode.type !== newVirdNode.type) {\n        const realNode = createRealNode(newVirdNode)\n        nextNode = realNode\n\n        if (oldNode) {\n          beforeVirdNodes.delete(oldNode)\n\n          if (newVirdNodeLength > oldVirdNodeLength) {\n            rootNode.insertBefore(realNode, oldNode)\n            oldVirdNodeIndex--\n          } else if (newVirdNodeLength < oldVirdNodeLength) {\n            rootNode.removeChild(oldNode)\n            newVirdNodeIndex--\n          } else {\n            rootNode.replaceChild(realNode, oldNode)\n          }\n        } else {\n          rootNode.appendChild(realNode)\n        }\n      }\n\n      if (nextNode) {\n        nodeMap.set(newVirdNode, nextNode)\n\n        const diffProperties = diff(\n          newVirdNode.properties,\n          oldVirdNode && oldVirdNode.properties\n        )\n\n        if (nextNode instanceof Element) {\n          for (const name of Object.keys(diffProperties)) {\n            const newValue = diffProperties[name]\n            const value = newValue && newValue[0]\n\n            if (value) {\n              nextNode.setAttribute(name, value)\n            } else {\n              nextNode.removeAttribute(name)\n            }\n          }\n\n          if (oldVirdNode) {\n            const oldEventMap = getVirdEventMap(oldVirdNode)\n            for (const name of Object.keys(oldEventMap)) {\n              const eventMap = oldEventMap[name]\n              for (const { listener } of eventMap) {\n                nextNode.removeEventListener(name, listener)\n              }\n            }\n          }\n\n          const oldEventMap = getVirdEventMap(newVirdNode)\n          for (const name of Object.keys(oldEventMap)) {\n            const eventMap = oldEventMap[name]\n            for (const { listener, options } of eventMap) {\n              nextNode.addEventListener(name, listener, options)\n            }\n          }\n        } else {\n          if (diffProperties.textContent) {\n            nextNode.textContent = diffProperties.textContent[0] || ''\n          }\n        }\n\n        diffRender(nextNode, newVirdNode.children)\n      }\n    } else if (oldNode) {\n      const parent = oldNode.parentElement\n      if (parent) {\n        parent.removeChild(oldNode)\n      }\n    }\n\n    index++\n    newVirdNodeIndex++\n    oldVirdNodeIndex++\n  }\n}\n","import { cloneNode } from '../create-node/clone-node'\nimport { VirdNode } from '../vird-node/vird-node'\nimport { virdNodeTypes } from '../vird-node/vird-node-types'\nimport { diffRender } from './diff-render'\n\nfunction filterIgnoreVirdNode(virdNodes: VirdNode[]) {\n  const result: VirdNode[] = []\n\n  for (const virdNode of virdNodes) {\n    if (virdNode.type === virdNodeTypes.fragment) {\n      const children = filterIgnoreVirdNode(virdNode.children)\n      result.push(...children)\n    } else {\n      result.push(virdNode)\n    }\n  }\n\n  return result\n}\n\nexport function render(rootNode: Node, ...virdNodes: VirdNode[]) {\n  const newVirdNodeLength = virdNodes.length\n  if (newVirdNodeLength < 1) return\n\n  // Create a VirdNode for rendering.\n  const clone = (virdNode: VirdNode) => cloneNode(virdNode, true)\n  const newVirdNodes = filterIgnoreVirdNode(virdNodes).map(clone)\n\n  // rendering.\n  diffRender(rootNode, newVirdNodes)\n}\n"],"names":[],"mappings":"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"}